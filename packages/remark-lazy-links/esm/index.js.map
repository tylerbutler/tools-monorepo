{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAAE,MAAM,SAAS,CAAC;AAqBxC;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,CAAC,MAAM,eAAe,GAAsC,CACjE,OAAO,GAAG,EAAE,EACX,EAAE;IACH,MAAM,EAAE,OAAO,GAAG,KAAK,EAAE,GAAG,OAAO,CAAC;IAEpC,OAAO,CAAC,IAAU,EAAE,IAAW,EAAE,EAAE;QAClC,+BAA+B;QAC/B,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC;QAEzC,+CAA+C;QAC/C,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC;YAC9B,OAAO;QACR,CAAC;QAED,0DAA0D;QAC1D,MAAM,YAAY,GAAG,aAAa,CAAC;QAEnC,6DAA6D;QAC7D,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,IAAI,KAA6B,CAAC;QAElC,YAAY,CAAC,SAAS,GAAG,CAAC,CAAC;QAC3B,OAAO,CAAC,KAAK,GAAG,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;YACtD,IAAI,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;gBACd,MAAM,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;gBACnC,IAAI,GAAG,GAAG,UAAU,EAAE,CAAC;oBACtB,UAAU,GAAG,GAAG,CAAC;gBAClB,CAAC;YACF,CAAC;QACF,CAAC;QAED,6BAA6B;QAC7B,IAAI,OAAO,GAAG,UAAU,CAAC;QAEzB,mDAAmD;QACnD,uCAAuC;QACvC,0CAA0C;QAC1C,0EAA0E;QAC1E,MAAM,SAAS,GACd,gEAAgE,CAAC;QAElE,yCAAyC;QACzC,iDAAiD;QACjD,IAAI,WAAW,GAAG,OAAO,CAAC;QAC1B,IAAI,UAAU,GAAG,KAAK,CAAC;QAEvB,OAAO,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC;YACpC,SAAS,CAAC,SAAS,GAAG,CAAC,CAAC;YACxB,WAAW,GAAG,WAAW,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,EAAE;gBACtE,OAAO,EAAE,CAAC;gBACV,UAAU,GAAG,IAAI,CAAC;gBAClB,OAAO,GAAG,MAAM,GAAG,OAAO,GAAG,MAAM,GAAG,OAAO,IAAI,CAAC;YACnD,CAAC,CAAC,CAAC;YACH,SAAS,CAAC,SAAS,GAAG,CAAC,CAAC;QACzB,CAAC;QAED,6DAA6D;QAC7D,IAAI,CAAC,KAAK,GAAG,WAAW,CAAC;QAEzB,yEAAyE;QACzE,IAAI,OAAO,IAAI,UAAU,EAAE,CAAC;YAC3B,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YACjD,IAAI,QAAQ,EAAE,CAAC;gBACd,IAAI,CAAC;oBACJ,aAAa,CAAC,QAAQ,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;oBAC9C,OAAO,CAAC,GAAG,CAAC,8BAA8B,QAAQ,EAAE,CAAC,CAAC;gBACvD,CAAC;gBAAC,OAAO,KAAK,EAAE,CAAC;oBAChB,OAAO,CAAC,IAAI,CACX,uCAAuC,QAAQ,GAAG,EAClD,KAAK,CACL,CAAC;gBACH,CAAC;YACF,CAAC;QACF,CAAC;IACF,CAAC,CAAC;AACH,CAAC,CAAC","sourcesContent":["import { writeFileSync } from \"node:fs\";\nimport type { Root } from \"mdast\";\nimport type { Plugin } from \"unified\";\nimport type { VFile } from \"vfile\";\n\ninterface LazyLinksOptions {\n\t/**\n\t * Whether to persist the transformed links back to source files.\n\t *\n\t * When false (default): Transformation happens in-memory only during build.\n\t * Source files remain unchanged with [*] markers.\n\t *\n\t * When true: Source files are permanently modified, replacing [*] with\n\t * numbered links. Useful if you want the transformed format to be the\n\t * canonical version or need to use files outside of Astro.\n\t *\n\t * @default false\n\t */\n\tpersist?: boolean;\n}\n\n/**\n * Remark plugin to transform lazy markdown links [*] into numbered references.\n *\n * Inspired by Brett Terpstra's lazy markdown reference links:\n * http://brettterpstra.com/2013/10/19/lazy-markdown-reference-links/\n *\n * Transforms:\n *   [link text][*]  and  [*]: http://url\n * Into:\n *   [link text][1]  and  [1]: http://url\n *\n * Features:\n * - Preserves existing numbered links\n * - Handles multiple overlapping lazy links\n * - Configurable persistence (in-memory or write back to source)\n *\n * @example\n * // In-memory transformation only (default)\n * remarkPlugins: [remarkLazyLinks]\n *\n * @example\n * // Persist changes back to source files\n * remarkPlugins: [[remarkLazyLinks, { persist: true }]]\n */\nexport const remarkLazyLinks: Plugin<[LazyLinksOptions?], Root> = (\n\toptions = {},\n) => {\n\tconst { persist = false } = options;\n\n\treturn (tree: Root, file: VFile) => {\n\t\t// Get the raw markdown content\n\t\tconst content = String(file.value || \"\");\n\n\t\t// Check if there are any lazy links to process\n\t\tif (!content.includes(\"[*]\")) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Regular expression to find existing numbered references\n\t\tconst counterRegex = /\\[(\\d+)\\]:/g;\n\n\t\t// Find the maximum existing numbered link to avoid conflicts\n\t\tlet maxCounter = 0;\n\t\tlet match: RegExpExecArray | null;\n\n\t\tcounterRegex.lastIndex = 0;\n\t\twhile ((match = counterRegex.exec(content)) !== null) {\n\t\t\tif (match[1]) {\n\t\t\t\tconst num = parseInt(match[1], 10);\n\t\t\t\tif (num > maxCounter) {\n\t\t\t\t\tmaxCounter = num;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Counter for new lazy links\n\t\tlet counter = maxCounter;\n\n\t\t// Regular expression to match lazy link references\n\t\t// Matches: [link text][*] ... [*]: url\n\t\t// Uses DOTALL (s) and MULTILINE (m) flags\n\t\t// The pattern needs to match from [text][*] to the corresponding [*]: url\n\t\tconst linkRegex =\n\t\t\t/(\\[[^\\]]+\\]\\s*\\[)\\*(\\](?:(?!\\[[^\\]]+\\]\\s*\\[)[\\s\\S])*?\\[)\\*\\]:/g;\n\n\t\t// Transform lazy links to numbered links\n\t\t// Use a while loop to handle overlapping matches\n\t\tlet transformed = content;\n\t\tlet hasChanges = false;\n\n\t\twhile (linkRegex.test(transformed)) {\n\t\t\tlinkRegex.lastIndex = 0;\n\t\t\ttransformed = transformed.replace(linkRegex, (match, group1, group2) => {\n\t\t\t\tcounter++;\n\t\t\t\thasChanges = true;\n\t\t\t\treturn `${group1}${counter}${group2}${counter}]:`;\n\t\t\t});\n\t\t\tlinkRegex.lastIndex = 0;\n\t\t}\n\n\t\t// Update the file content for further processing (in-memory)\n\t\tfile.value = transformed;\n\n\t\t// If persist is enabled and changes were made, write back to source file\n\t\tif (persist && hasChanges) {\n\t\t\tconst filepath = file.history && file.history[0];\n\t\t\tif (filepath) {\n\t\t\t\ttry {\n\t\t\t\t\twriteFileSync(filepath, transformed, \"utf-8\");\n\t\t\t\t\tconsole.log(`✨ Lazy links persisted to: ${filepath}`);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`⚠️  Failed to persist lazy links to ${filepath}:`,\n\t\t\t\t\t\terror,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n"]}