## API Report File for "@tylerbu/cli-api"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Command } from '@oclif/core';
import type { Config } from '@oclif/core';
import { CustomOptions } from '@oclif/core/interfaces';
import { Debugger } from 'debug';
import { FlagDefinition } from '@oclif/core/interfaces';
import type { Indent } from 'detect-indent';
import { Interfaces } from '@oclif/core';
import { OptionFlag } from '@oclif/core/interfaces';
import type { PackageJson } from 'type-fest';
import type { SetRequired } from 'type-fest';
import { SimpleGit } from 'simple-git';
import { SimpleGitOptions } from 'simple-git';

// @public
export type Args<T extends typeof Command> = Interfaces.InferredArgs<T["args"]>;

// @public
export abstract class BaseCommand<T extends typeof Command> extends Command {
    // (undocumented)
    protected args: Args<T>;
    static baseFlags: {
        verbose: Interfaces.BooleanFlag<boolean>;
        quiet: Interfaces.BooleanFlag<boolean>;
    };
    exit(code?: number): never;
    exit(message: string | Error, code?: number): never;
    // (undocumented)
    protected flags: Flags<T>;
    info(message: string | Error | undefined, ..._args: unknown[]): void;
    // (undocumented)
    init(): Promise<void>;
    log(message?: string, ..._args: unknown[]): void;
    logError(message: string | Error | undefined, ..._args: unknown[]): void;
    get logger(): Logger;
    protected _logger: Logger;
    protected redirectLogToTrace: boolean;
    success(message?: string, ..._args: unknown[]): void;
    // (undocumented)
    protected trace: Debugger | undefined;
    verbose(message: string | Error | undefined, ..._args: unknown[]): void;
    // @deprecated
    warn(_input: string | Error): string | Error;
    warning(message: string | Error | undefined, ..._args: unknown[]): void;
    warningWithDebugTrace(message: string | Error | undefined): void;
}

// @beta
export interface Capability<TCommand extends BaseCommand<any>, TResult = unknown> {
    cleanup?(): Promise<void> | void;
    initialize(command: TCommand): Promise<TResult> | TResult;
}

// @beta
export class CapabilityWrapper<TCommand extends BaseCommand<any>, TResult> {
    constructor(command: TCommand, capability: Capability<TCommand, TResult>);
    cleanup(): Promise<void>;
    get(): Promise<TResult>;
    get isInitialized(): boolean;
}

// @beta
export function checkConflicts(git: SimpleGit, commitIds: string[], log?: Logger): Promise<{
    commit: string;
    mergeability: CommitMergeability;
}[]>;

// @beta
export abstract class CommandWithConfig<T extends typeof Command & {
    args: typeof CommandWithConfig.args;
    flags: typeof CommandWithConfig.flags;
}, C> extends BaseCommand<T> {
    // (undocumented)
    protected get commandConfig(): C | undefined;
    protected get configLocation(): string | "DEFAULT" | undefined;
    protected defaultConfig: C | undefined;
    // (undocumented)
    static readonly flags: {
        readonly config: OptionFlag<string | undefined, CustomOptions>;
    };
    // (undocumented)
    init(): Promise<void>;
    protected requiresConfig: boolean;
}

// @beta
export interface CommandWithContext<CONTEXT> {
    // (undocumented)
    getContext(): Promise<CONTEXT>;
}

// @beta
export type CommitMergeability = "clean" | "conflict" | "maybeClean";

// @beta
export class ConfigCapability<TCommand extends BaseCommand<any>, TConfig> implements Capability<TCommand, ConfigContext<TConfig>> {
    constructor(options?: ConfigCapabilityOptions<TConfig>);
    // (undocumented)
    initialize(command: TCommand): Promise<ConfigContext<TConfig>>;
}

// @beta
export interface ConfigCapabilityOptions<TConfig> {
    defaultConfig?: TConfig;
    required?: boolean;
    searchPaths?: string[];
}

// @beta
export type ConfigContext<TConfig> = ConfigContextFound<TConfig> | ConfigContextNotFound;

// @beta
export interface ConfigContextFound<TConfig> {
    config: TConfig;
    found: true;
    isDefault(): boolean;
    location: string | DefaultConfigLocation;
}

// @beta
export interface ConfigContextNotFound {
    config: undefined;
    found: false;
    isDefault(): false;
    location: undefined;
}

// @beta
export const ConfigFlag: OptionFlag<string | undefined, CustomOptions>;

// @beta
export const ConfigFlagHidden: OptionFlag<string | undefined, CustomOptions>;

// @public
export interface ConsolaLoggerOptions {
    colors?: boolean;
}

// @public
export function createBasicLogger(): Logger;

// @public
export function createConsolaLogger(style?: PrefixStyle, options?: ConsolaLoggerOptions): Logger;

// @public
export function createExtendedConsolaLogger(style: PrefixStyle, options?: ConsolaLoggerOptions): ExtendedLogger;

// @beta
export type DefaultConfigLocation = "DEFAULT" & {
    readonly __brand: "DefaultConfigLocation";
};

// @beta
export interface DependencyChange {
    // (undocumented)
    dep: string;
    // (undocumented)
    from: string;
    // (undocumented)
    to: string;
    // (undocumented)
    type: DependencyType;
}

// @beta
export interface DependencyInfo {
    // (undocumented)
    [key: string]: unknown;
    // (undocumented)
    version: string;
}

// @beta
export type DependencyType = "dependencies" | "devDependencies" | "peerDependencies" | "optionalDependencies";

// @beta
export function detectAllPackageManagers(directory?: string): Promise<PackageManager[]>;

// @beta
export function detectFromLockfilePath(lockfilePath: string): PackageManager | null;

// @beta
export function detectPackageManager(directory?: string): Promise<PackageManager | undefined>;

// @public
export type ErrorLoggingFunction = (msg: string | Error | undefined, ...args: unknown[]) => void;

// @public
export interface ExtendedLogger extends Logger {
    debug: ErrorLoggingFunction;
    fatal: ErrorLoggingFunction;
    trace: ErrorLoggingFunction;
}

// @beta (undocumented)
export function findGitRoot(cwd?: string): Promise<string>;

// @public
export type Flags<T extends typeof Command> = Interfaces.InferredFlags<(typeof BaseCommand)["baseFlags"] & T["flags"]>;

// @beta
export function getAllLockfiles(): string[];

// @beta
export function getInstalledVersions(packageManager: PackageManager, options?: GetInstalledVersionsOptions): Promise<ProjectInfo[]>;

// @beta
export interface GetInstalledVersionsOptions {
    cwd?: string;
}

// @beta (undocumented)
export function getMergeBase(git: SimpleGit, reference1: string, reference2: string): Promise<string>;

// @beta
export function getPackageManagerInfo(pm: PackageManager): PackageManagerInfo;

// @beta
export class GitCapability<TCommand extends BaseCommand<any>> implements Capability<TCommand, GitContext> {
    constructor(options?: GitCapabilityOptions);
    // (undocumented)
    initialize(command: TCommand): Promise<GitContext>;
}

// @beta
export interface GitCapabilityOptions {
    baseDir?: string;
    required?: boolean;
}

// @beta
export abstract class GitCommand<T extends typeof Command & {
    args: typeof GitCommand.args;
    flags: typeof GitCommand.flags;
}, C = undefined> extends CommandWithConfig<T, C> {
    constructor(argv: string[], config: Config);
    // (undocumented)
    protected git: SimpleGit;
    // (undocumented)
    protected repo: Repository;
    protected requiresConfig: boolean;
}

// @beta
export interface GitContext {
    getCurrentBranch(): Promise<string>;
    git: SimpleGit;
    hasUncommittedChanges(): Promise<boolean>;
    isCleanWorkingTree(): Promise<boolean>;
    isRepo: boolean;
    repo: Repository;
}

// @beta
export function isSyncSupported(pm: PackageManager): boolean;

// @beta
export interface JsonWriteOptions {
    indent?: string | Indent | undefined;
    sort?: true | undefined;
}

// @public
export interface Logger {
    error: ErrorLoggingFunction;
    formatError?: ((message: Error | string) => string) | undefined;
    info: ErrorLoggingFunction;
    log: (message?: string, ...args: unknown[]) => void;
    success: LoggingFunction;
    verbose: ErrorLoggingFunction;
    warning: ErrorLoggingFunction;
}

// @public
export type LoggingFunction = (message?: string, ...args: unknown[]) => void;

// @public
export function logIndent(input: string, logger: Logger, indentNumber?: number): void;

// @beta
export type PackageManager = "npm" | "pnpm" | "yarn" | "bun";

// @beta
export interface PackageManagerInfo {
    // (undocumented)
    listCommand: string;
    // (undocumented)
    lockfile: string;
    // (undocumented)
    name: PackageManager;
}

// @beta
export type PackageTransformer<J extends PackageJson = PackageJson> = (json: J) => J | Promise<J>;

// @public
export type PrefixStyle = "capsule" | "candy-wrapper" | "tape";

// @beta
export interface ProjectInfo {
    // (undocumented)
    dependencies?: Record<string, DependencyInfo>;
    // (undocumented)
    devDependencies?: Record<string, DependencyInfo>;
    // (undocumented)
    name: string;
    // (undocumented)
    optionalDependencies?: Record<string, DependencyInfo>;
    // (undocumented)
    path: string;
    // (undocumented)
    peerDependencies?: Record<string, DependencyInfo>;
}

// @beta
export function readJsonWithIndent<J = unknown>(filePath: string): Promise<{
    json: J;
    indent: Indent;
}>;

// @beta
export const RegExpFlag: FlagDefinition<RegExp, CustomOptions, {
multiple: false;
requiredOrDefaulted: false;
}>;

// @public
export class Repository {
    constructor(gitOptions: SetRequired<Partial<SimpleGitOptions>, "baseDir">);
    get gitClient(): SimpleGit;
}

// @beta
export interface RequiresGit {
    // (undocumented)
    git: SimpleGit;
}

// @alpha
export function revList(git: SimpleGit, baseCommit: string, headCommit?: string): Promise<string[]>;

// @public
export function shortCommit(commit: string): string;

// @beta
export function syncAllPackages(projects: ProjectInfo[], options?: SyncPackageJsonOptions): Promise<SyncAllResult>;

// @beta
export interface SyncAllResult {
    // (undocumented)
    results: SyncResult[];
    // (undocumented)
    skippedProjects: Array<{
        name: string;
        path: string;
        reason: string;
    }>;
}

// @beta
export interface SyncPackageJsonOptions {
    versionRangeOptions?: UpdateVersionRangeOptions;
    write?: boolean;
}

// @beta
export interface SyncResult {
    // (undocumented)
    changes: DependencyChange[];
    // (undocumented)
    packagePath: string;
    // (undocumented)
    warnings?: string[];
}

// @beta
export function updatePackageJsonFile<J extends PackageJson = PackageJson>(packagePath: string, packageTransformer: PackageTransformer, options?: JsonWriteOptions): Promise<void>;

// @beta
export interface UpdateVersionRangeOptions {
    emitWarnings?: boolean;
}

// @beta
export function useConfig<TCommand extends BaseCommand<any>, TConfig>(command: TCommand, options?: ConfigCapabilityOptions<TConfig>): CapabilityWrapper<TCommand, ConfigContext<TConfig>>;

// @beta
export function useGit<TCommand extends BaseCommand<any>>(command: TCommand, options?: GitCapabilityOptions): CapabilityWrapper<TCommand, GitContext>;

```
