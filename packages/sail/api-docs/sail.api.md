## API Report File for "@tylerbu/sail"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AsyncPriorityQueue } from 'async';
import type { BuildProjectConfig } from '@tylerbu/sail-infrastructure';
import child_process from 'node:child_process';
import { IBuildProject } from '@tylerbu/sail-infrastructure';
import { IPackage } from '@tylerbu/sail-infrastructure';
import { IPackageManager } from '@tylerbu/sail-infrastructure';
import { IReleaseGroup } from '@tylerbu/sail-infrastructure';
import { IWorkspace } from '@tylerbu/sail-infrastructure';
import { Logger } from '@tylerbu/cli-api';
import { PackageBase } from '@tylerbu/sail-infrastructure';
import { PackageJson } from '@tylerbu/sail-infrastructure';
import { ReleaseGroupName } from '@tylerbu/sail-infrastructure';
import type { SimpleGit } from 'simple-git';
import { WorkspaceName } from '@tylerbu/sail-infrastructure';

// @beta (undocumented)
export type AnyTaskName = "*";

// @beta
export interface BuildContext {
    // (undocumented)
    readonly buildProjectConfig: BuildProjectConfig;
    readonly gitRepo: SimpleGit;
    readonly gitRoot: string;
    // (undocumented)
    readonly log: Logger;
    // @deprecated
    readonly repoRoot: string;
    readonly sailConfig: ISailConfig;
    readonly sharedCache?: SharedCacheManager;
    readonly taskHandlerRegistry: TaskHandlerRegistry;
}

// @internal (undocumented)
export class BuildGraphContext implements BuildContext, IBuildExecutionContext {
    constructor(repoPackageMap: ReadonlyMap<string, BuildPackage>, buildContext: BuildContext, force: boolean, matchedOnly: boolean, quiet: boolean, workerPool?: WorkerPool | undefined);
    // (undocumented)
    readonly buildContext: BuildContext;
    // (undocumented)
    readonly buildProfiler: BuildProfiler;
    // (undocumented)
    readonly buildProjectConfig: BuildProjectConfig;
    // (undocumented)
    readonly failedTaskLines: string[];
    // (undocumented)
    readonly fileHashCache: FileHashCache;
    // (undocumented)
    readonly force: boolean;
    // (undocumented)
    readonly gitRepo: SimpleGit;
    // (undocumented)
    readonly gitRoot: string;
    // (undocumented)
    readonly log: Logger;
    // (undocumented)
    readonly matchedOnly: boolean;
    // (undocumented)
    readonly quiet: boolean;
    // (undocumented)
    readonly repoPackageMap: ReadonlyMap<string, BuildPackage>;
    // (undocumented)
    readonly repoRoot: string;
    // (undocumented)
    readonly sailConfig: ISailConfig;
    // (undocumented)
    readonly sharedCache?: SharedCacheManager;
    // (undocumented)
    readonly taskHandlerRegistry: TaskHandlerRegistry;
    // (undocumented)
    readonly taskStats: TaskStats;
    // (undocumented)
    readonly verbose: boolean;
    // (undocumented)
    readonly workerPool?: WorkerPool | undefined;
}

// @beta
export class BuildGraphPackage implements DependencyNode, IBuildablePackage {
    // @internal
    constructor(context: BuildGraphContext, pkg: BuildPackage, globalTaskDefinitions: TaskDefinitions);
    // (undocumented)
    build(q: AsyncPriorityQueue<TaskExec>): Promise<IBuildResult>;
    // (undocumented)
    createTasks(buildTaskNames: string[]): boolean | undefined;
    // @internal (undocumented)
    readonly dependentPackages: BuildGraphPackage[];
    // @internal (undocumented)
    get failedTaskLines(): string[];
    // @internal (undocumented)
    get fileHashCache(): FileHashCache;
    // (undocumented)
    finalizeDependentTasks(): void;
    // @internal (undocumented)
    get force(): boolean;
    // (undocumented)
    getDependsOnTasks(task: Task, taskName: string, pendingInitDep: Task[]): Task[];
    // (undocumented)
    getLockFileHash(): Promise<string>;
    // (undocumented)
    getScriptTask(taskName: string, pendingInitDep: Task[]): Task | undefined;
    // (undocumented)
    getTask(taskName: string, pendingInitDep: Task[] | undefined): Task | undefined;
    // (undocumented)
    initializeDependentLeafTasks(): void;
    // (undocumented)
    initializeWeight(): void;
    // (undocumented)
    isUpToDate(): Promise<boolean>;
    // @internal (undocumented)
    level: number;
    // @internal (undocumented)
    get log(): Logger;
    // @internal (undocumented)
    get matchedOnly(): boolean;
    // (undocumented)
    readonly pkg: BuildPackage;
    // @internal (undocumented)
    get repoPackageMap(): ReadonlyMap<string, BuildPackage>;
    reset(): void;
    // @internal (undocumented)
    get sailConfig(): ISailConfig;
    // @internal (undocumented)
    get sharedCache(): SharedCacheManager | undefined;
    // (undocumented)
    get taskCount(): number;
    // (undocumented)
    readonly taskManager: TaskManager;
    // @internal (undocumented)
    get taskStats(): TaskStats;
    // @internal (undocumented)
    get verbose(): boolean;
    // @internal (undocumented)
    get workerPool(): WorkerPool | undefined;
}

// @beta (undocumented)
export class BuildPackage extends PackageBase<SailPackageJson> {
    constructor(packageInput: IPackage);
    // (undocumented)
    cleanNodeModules(): Promise<ExecAsyncResult>;
    getLockFilePath(): string | undefined;
    // (undocumented)
    get matched(): boolean;
    set matched(value: boolean);
    // @internal @deprecated (undocumented)
    get monoRepo(): MonoRepo | undefined;
}

// @internal
export interface BuildPerformanceReport extends PerformanceReport {
    // (undocumented)
    buildDuration: number;
    // (undocumented)
    packageMetrics: PackageMetrics[];
    // (undocumented)
    recommendations: string[];
}

// @internal
export class BuildProfiler {
    constructor(logger: Logger);
    endBuild(): BuildPerformanceReport;
    getSnapshot(): PerformanceReport;
    logReport(report: BuildPerformanceReport): void;
    // (undocumented)
    readonly performanceMonitor: PerformanceMonitor;
    profileConfigurationParsing<T>(operation: () => T, packageName: string, configType: string): T;
    profileDependencyResolution<T>(operation: () => Promise<T>, packageCount: number): Promise<T>;
    profileFileOperation<T>(operation: () => Promise<T>, operationType: FileOperationType, filePath?: string): Promise<T>;
    profileTaskCreation<T>(operation: () => T, packageName: string, taskCount: number): T;
    profileTaskExecution<T>(operation: () => Promise<T>, packageName: string, taskName: string): Promise<T>;
    recordCacheEvent(type: CacheEventType, key: string, hit: boolean): void;
    startBuild(): void;
}

// @beta
export const BuildResult: {
    readonly Success: "Success";
    readonly UpToDate: "UpToDate";
    readonly Failed: "Failed";
    readonly CachedSuccess: "CachedSuccess";
    readonly LocalCacheHit: "LocalCacheHit";
    readonly SuccessWithCacheWrite: "SuccessWithCacheWrite";
};

// @beta
export type BuildResult = (typeof BuildResult)[keyof typeof BuildResult];

// @beta
export interface CacheEntry {
    cacheKey: string;
    entryPath: string;
    isUnexpectedError?: boolean;
    manifest: CacheManifest;
}

// @internal
export const CacheEventType: {
    readonly FileHash: "file-hash";
    readonly TaskResult: "task-result";
    readonly Configuration: "configuration";
};

// @internal
export type CacheEventType = (typeof CacheEventType)[keyof typeof CacheEventType];

// @beta
export interface CacheKeyInputs {
    arch: string;
    cacheBustVars?: Record<string, string>;
    cacheSchemaVersion: number;
    command: string;
    configHashes?: Record<string, string>;
    dependencyHashes?: ReadonlyArray<{
        readonly name: string;
        readonly hash: string;
    }>;
    executable: string;
    inputHashes: ReadonlyArray<{
        readonly path: string;
        readonly hash: string;
    }>;
    lockfileHash: string;
    nodeEnv?: string;
    nodeVersion: string;
    packageName: string;
    platform: string;
    taskName: string;
    toolVersion?: string;
}

// @beta
export interface CacheManifest {
    arch: string;
    cacheBustVars?: Record<string, string>;
    cacheKey: string;
    cacheSchemaVersion: number;
    command: string;
    createdAt: string;
    executable: string;
    executionTimeMs: number;
    exitCode: 0;
    inputFiles: ReadonlyArray<{
        readonly path: string;
        readonly hash: string;
    }>;
    lastAccessedAt: string;
    lockfileHash: string;
    nodeEnv?: string;
    nodeVersion: string;
    outputFiles: ReadonlyArray<{
        readonly path: string;
        readonly hash: string;
        readonly size: number;
        readonly mtime: number;
    }>;
    packageName: string;
    platform: string;
    stderr: string;
    stdout: string;
    taskName: string;
    version: 1;
}

// @beta
export interface CacheStatistics {
    avgRestoreTime: number;
    avgStoreTime: number;
    hitCount: number;
    lastPruned?: string;
    missCount: number;
    timeSavedMs: number;
    totalEntries: number;
    totalSize: number;
}

// @beta
export interface DeclarativeTask {
    gitignore?: GitIgnoreSetting;
    inputGlobs: string[];
    outputGlobs: string[];
}

// @beta
export interface DeclarativeTasks {
    // (undocumented)
    [executable: string]: DeclarativeTask;
}

// @beta (undocumented)
export interface DependencyNode extends IDependencyNode {
    // (undocumented)
    dependentPackages: DependencyNode[];
    // (undocumented)
    level: number;
    // (undocumented)
    pkg: BuildPackage;
}

// @beta (undocumented)
export interface ExecAsyncResult {
    // (undocumented)
    error: child_process.ExecException | null;
    // (undocumented)
    stderr: string;
    // (undocumented)
    stdout: string;
}

// @internal (undocumented)
export class FileHashCache {
    // (undocumented)
    clear(): void;
    // (undocumented)
    protected fileHashCaches: Map<hashFn, Map<string, Promise<string>>>;
    // (undocumented)
    getFileHash(path: string, hash?: hashFn): Promise<string>;
}

// @internal
export const FileOperationType: {
    readonly Read: "read";
    readonly Write: "write";
    readonly Stat: "stat";
    readonly Hash: "hash";
    readonly Glob: "glob";
};

// @internal
export type FileOperationType = (typeof FileOperationType)[keyof typeof FileOperationType];

// @beta
export function getSailConfig(rootDir: string, noCache?: boolean, log?: Logger): {
    config: ISailConfig;
    configFilePath: string;
};

// @beta (undocumented)
export type GitIgnoreSetting = ("input" | "output")[];

// @beta
export interface GlobalCacheKeyComponents {
    arch: string;
    cacheBustVars?: Record<string, string>;
    cacheSchemaVersion: number;
    lockfileHash: string;
    nodeEnv?: string;
    nodeVersion: string;
    platform: string;
}

// @internal (undocumented)
export type hashFn = (buffer: Buffer) => string;

// @beta
export interface IBuildablePackage {
    // (undocumented)
    build(q: AsyncPriorityQueue<TaskExec>): Promise<IBuildResult>;
    // (undocumented)
    isUpToDate(): Promise<boolean>;
}

// @internal
export interface IBuildExecutionContext {
    // (undocumented)
    readonly buildProfiler?: BuildProfiler;
    // (undocumented)
    readonly failedTaskLines: string[];
    // (undocumented)
    readonly fileHashCache: {
        clear(): void;
    };
    // (undocumented)
    readonly quiet: boolean;
    // (undocumented)
    readonly taskStats: IBuildStats;
    // (undocumented)
    readonly workerPool?: {
        reset(): void;
    };
}

// @beta
export type IBuildResult = "Success" | "UpToDate" | "Failed" | "CachedSuccess" | "LocalCacheHit" | "SuccessWithCacheWrite";

// @internal
export interface IBuildStats {
    // (undocumented)
    leafBuiltCount: number;
    // (undocumented)
    leafExecTimeTotal: number;
    leafInitialUpToDateCount: number;
    // (undocumented)
    leafQueueWaitTimeTotal: number;
    // (undocumented)
    leafTotalCount: number;
    // (undocumented)
    leafUpToDateCount: number;
}

// @public
export interface ICacheableTask {
    readonly canUseCache: boolean;
    getCacheInputFiles(): Promise<string[]>;
    getCacheOutputFiles(): Promise<string[]>;
}

// @beta
export type IDependencyNode = {
    pkg: BuildPackage;
    dependentPackages: IDependencyNode[];
    level: number;
};

// @beta
export interface ISailConfig {
    buildProject: BuildProjectConfig;
    declarativeTasks?: DeclarativeTasks;
    multiCommandExecutables?: string[];
    plugins?: TaskHandlerPlugin[];
    tasks?: TaskDefinitionsOnDisk;
    version: number;
}

// @beta (undocumented)
export abstract class LeafTask extends Task implements ICacheableTask {
    constructor(node: BuildGraphPackage, command: string, context: BuildContext, taskName: string | undefined, isTemp?: boolean);
    // (undocumented)
    addDependentLeafTasks(dependentLeafTasks: Iterable<LeafTask>): void;
    get canUseCache(): boolean;
    // (undocumented)
    protected checkIsUpToDate(): Promise<boolean>;
    // (undocumented)
    protected abstract checkLeafIsUpToDate(): Promise<boolean>;
    // (undocumented)
    collectLeafTasks(leafTasks: Set<LeafTask>): void;
    // (undocumented)
    protected dependentTaskPromises?: Promise<BuildResult>[];
    // (undocumented)
    exec(): Promise<BuildResult>;
    // (undocumented)
    get executable(): string;
    // (undocumented)
    protected get executionCommand(): string;
    getCacheInputFiles(): Promise<string[]>;
    getCacheOutputFiles(): Promise<string[]>;
    protected getDependencyHashes(): Promise<Array<{
        name: string;
        hash: string;
    }>>;
    // (undocumented)
    protected getDependentLeafTasks(): SetIterator<LeafTask>;
    protected getPackageFileFullPath(filePath: string): string;
    // (undocumented)
    protected getVsCodeErrorMessages(errorMessages: string): string;
    // (undocumented)
    initializeDependentLeafTasks(): void;
    // (undocumented)
    initializeWeight(): number;
    // (undocumented)
    get isDisabled(): boolean;
    protected abstract get isIncremental(): boolean | undefined;
    // (undocumented)
    protected markExecDone(): Promise<void>;
    protected get recheckLeafIsUpToDate(): boolean;
    // (undocumented)
    protected runTask(q: AsyncPriorityQueue<TaskExec>): Promise<BuildResult>;
    // (undocumented)
    protected get taskWeight(): number;
    // (undocumented)
    protected get useWorker(): boolean;
    // (undocumented)
    get weight(): number;
}

// @internal
export interface MemoryDelta {
    // (undocumented)
    external: number;
    // (undocumented)
    heapTotal: number;
    // (undocumented)
    heapUsed: number;
    // (undocumented)
    rss: number;
}

// @internal
export interface MemoryMetric {
    // (undocumented)
    external: number;
    // (undocumented)
    heapTotal: number;
    // (undocumented)
    heapUsed: number;
    // (undocumented)
    label: string;
    // (undocumented)
    rss: number;
    // (undocumented)
    timestamp: number;
}

// @beta (undocumented)
export class MonoRepo implements IWorkspace {
    constructor(kind: string, repoPath: string, releaseGroupName: ReleaseGroupName, workspace: IWorkspace);
    // (undocumented)
    get buildProject(): IBuildProject<IPackage>;
    // (undocumented)
    checkInstall(): Promise<true | string[]>;
    // (undocumented)
    get directory(): string;
    // (undocumented)
    install(updateLockfile: boolean): Promise<boolean>;
    // (undocumented)
    readonly kind: string;
    // (undocumented)
    get name(): WorkspaceName;
    // (undocumented)
    get packageManager(): IPackageManager;
    // (undocumented)
    get packages(): IPackage<PackageJson>[];
    // (undocumented)
    get releaseGroup(): IReleaseGroup;
    // (undocumented)
    get releaseGroups(): Map<ReleaseGroupName, IReleaseGroup>;
    // (undocumented)
    reload(): void;
    // (undocumented)
    readonly repoPath: string;
    // (undocumented)
    get rootPackage(): IPackage;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get version(): string;
}

// @internal
export interface PackageMetrics {
    // (undocumented)
    configParsingTime: number;
    // (undocumented)
    packageName: string;
    // (undocumented)
    taskCount: number;
    // (undocumented)
    taskCreationTime: number;
    // (undocumented)
    taskExecutionTime: number;
}

// @beta (undocumented)
export type PackageName = string;

// @internal
export interface PerformanceMetric {
    // (undocumented)
    count: number;
    // (undocumented)
    endTime: number;
    // (undocumented)
    lastDuration: number;
    // (undocumented)
    maxDuration: number;
    // (undocumented)
    memoryDelta?: MemoryDelta;
    // (undocumented)
    metadata?: Record<string, unknown>;
    // (undocumented)
    minDuration: number;
    // (undocumented)
    name: string;
    // (undocumented)
    startTime: number;
    // (undocumented)
    totalDuration: number;
}

// @internal
export class PerformanceMonitor {
    endTimer(name: string): PerformanceMetric | undefined;
    exportMetrics(): string;
    generateReport(): PerformanceReport;
    getMemoryUsage(): NodeJS.MemoryUsage;
    getMetric(name: string): PerformanceMetric | undefined;
    getMetrics(): PerformanceMetric[];
    recordMemoryUsage(label: string): MemoryMetric;
    recordMetric(metric: PerformanceMetric): void;
    reset(): void;
    startTimer(name: string, metadata?: Record<string, unknown>): PerformanceTimer;
    timeAsync<T>(name: string, operation: () => Promise<T>, metadata?: Record<string, unknown>): Promise<{
        result: T;
        metric: PerformanceMetric;
    }>;
    timeSync<T>(name: string, operation: () => T, metadata?: Record<string, unknown>): {
        result: T;
        metric: PerformanceMetric;
    };
}

// @internal
export interface PerformanceReport {
    // (undocumented)
    averageTime: number;
    // (undocumented)
    memoryUsage: NodeJS.MemoryUsage;
    // (undocumented)
    metrics: PerformanceMetric[];
    // (undocumented)
    mostFrequentOperations: PerformanceMetric[];
    // (undocumented)
    slowestOperations: PerformanceMetric[];
    // (undocumented)
    totalOperations: number;
    // (undocumented)
    totalTime: number;
    // (undocumented)
    totalTimeConsumers: PerformanceMetric[];
}

// @internal
export class PerformanceTimer {
    constructor(name: string, metadata?: Record<string, unknown>);
    cancel(): void;
    end(): PerformanceMetric;
    // (undocumented)
    readonly metadata: Record<string, unknown>;
    // (undocumented)
    readonly name: string;
}

// @beta
export interface RestoreResult {
    bytesRestored: number;
    error?: string;
    filesRestored: number;
    isUnexpectedFailure?: boolean;
    restoreTimeMs: number;
    stderr?: string;
    stdout?: string;
    success: boolean;
}

// @beta
export type SailPackageJson = PackageJson & {
    sail?: ISailConfig;
    fluidBuild?: ISailConfig;
};

// @beta
export interface SailPlugin {
    handlers: Record<string, TaskHandler>;
    name?: string;
}

// @beta
export class SharedCacheManager {
    constructor(options: SharedCacheOptions);
    cleanCache(): Promise<void>;
    displayStatistics(): Promise<void>;
    getGlobalKeyComponents(): GlobalCacheKeyComponents;
    getStatistics(): Readonly<CacheStatistics>;
    initialize(): Promise<void>;
    lookup(inputs: CacheKeyInputs): Promise<CacheEntry | undefined>;
    // (undocumented)
    readonly options: SharedCacheOptions;
    persistStatistics(): Promise<void>;
    pruneCache(maxSizeMB?: number, maxAgeDays?: number): Promise<number>;
    resetStatistics(): void;
    restore(entry: CacheEntry, packageRoot: string): Promise<RestoreResult>;
    store(inputs: CacheKeyInputs, outputs: TaskOutputs, _packageRoot: string, // eslint-disable-line @typescript-eslint/no-unused-vars
    lookupWasPerformed?: boolean): Promise<StoreResult>;
    verifyCache(fix?: boolean): Promise<{
        total: number;
        valid: number;
        corrupted: number;
        fixed: number;
    }>;
    waitForPendingOperations(): Promise<void>;
}

// @beta
export interface SharedCacheOptions {
    cacheDir: string;
    globalKeyComponents: GlobalCacheKeyComponents;
    logger: Logger;
    // @internal
    overwriteCache?: boolean;
    repoRoot: string;
    skipCacheWrite?: boolean;
    verifyIntegrity?: boolean;
}

// @beta
export interface StoreResult {
    bytesStored?: number;
    filesStored?: number;
    reason?: string;
    success: boolean;
}

// @beta (undocumented)
export abstract class Task {
    protected constructor(node: BuildGraphPackage, command: string, context: BuildContext, taskName: string | undefined);
    // (undocumented)
    abstract addDependentLeafTasks(dependentTasks: Iterable<LeafTask>): void;
    // (undocumented)
    addDependentTasks(dependentTasks: Task[], isDefault?: boolean): void;
    // (undocumented)
    protected abstract checkIsUpToDate(): Promise<boolean>;
    protected clearUpToDateCache(): void;
    // (undocumented)
    abstract collectLeafTasks(leafTasks: Set<LeafTask>): void;
    // (undocumented)
    readonly command: string;
    // (undocumented)
    protected readonly context: BuildContext;
    // (undocumented)
    static createTaskQueue(): AsyncPriorityQueue<TaskExec>;
    // (undocumented)
    get forced(): boolean;
    // (undocumented)
    abstract initializeDependentLeafTasks(): void;
    // (undocumented)
    initializeDependentTasks(pendingInitDep: Task[]): void;
    // (undocumented)
    abstract initializeWeight(): void;
    // (undocumented)
    isUpToDate(): Promise<boolean>;
    // (undocumented)
    protected get log(): Logger;
    // (undocumented)
    get name(): string;
    // (undocumented)
    get nameColored(): string;
    // (undocumented)
    protected readonly node: BuildGraphPackage;
    // (undocumented)
    get package(): BuildPackage;
    reset(): void;
    // (undocumented)
    run(q: AsyncPriorityQueue<TaskExec>): Promise<BuildResult>;
    // (undocumented)
    protected abstract runTask(q: AsyncPriorityQueue<TaskExec>): Promise<BuildResult>;
    // (undocumented)
    readonly taskName: string | undefined;
    // (undocumented)
    toString(): string;
    // (undocumented)
    protected traceError(msg: string): void;
    // (undocumented)
    protected traceExec(msg: string): void;
    // (undocumented)
    protected traceNotUpToDate(): void;
    // (undocumented)
    protected traceTrigger(reason: string): void;
    // (undocumented)
    protected get transitiveDependentLeafTask(): LeafTask[];
}

// @beta (undocumented)
export interface TaskConfig {
    // @internal
    readonly after: TaskDependencies;
    // @internal
    readonly before: TaskDependencies;
    // @internal
    readonly children: readonly TaskName[];
    // @internal
    readonly dependsOn: TaskDependencies;
    readonly script: boolean;
}

// @beta (undocumented)
export type TaskConfigOnDisk = TaskDependencies | Omit<Partial<TaskConfig>, "children">;

// @beta (undocumented)
export type TaskDefinition = TaskConfig & {
    readonly isDefault?: boolean;
};

// @beta
export interface TaskDefinitions {
    // (undocumented)
    readonly [name: string]: TaskConfig;
}

// @beta (undocumented)
export interface TaskDefinitionsOnDisk {
    // (undocumented)
    readonly [name: TaskName]: TaskConfigOnDisk;
}

// @beta (undocumented)
export type TaskDependencies = readonly TaskDependency[];

// @beta (undocumented)
export type TaskDependency = TaskName | AnyTaskName | `^${TaskName | AnyTaskName}` | `${PackageName}#${TaskName | AnyTaskName}` | "...";

// @beta (undocumented)
export interface TaskExec {
    // (undocumented)
    queueTime: number;
    // (undocumented)
    resolve: (value: BuildResult) => void;
    // (undocumented)
    task: LeafTask;
}

// @beta
export type TaskHandler = TaskHandlerConstructor | TaskHandlerFunction;

// @beta
export type TaskHandlerConstructor = new (node: BuildGraphPackage, command: string, context: BuildContext, taskName?: string) => LeafTask;

// @beta
export type TaskHandlerFunction = (node: BuildGraphPackage, command: string, context: BuildContext, taskName?: string) => LeafTask;

// @beta
export type TaskHandlerPlugin = string | TaskHandlerPluginConfig;

// @beta
export interface TaskHandlerPluginConfig {
    exportName?: string;
    module: string;
}

// @beta
export class TaskHandlerRegistry {
    clear(): void;
    get(executable: string): TaskHandler | undefined;
    getRegisteredExecutables(): string[];
    has(executable: string): boolean;
    loadHandler(executable: string, config: TaskHandlerPluginConfig, baseDir?: string): Promise<void>;
    loadHandlers(handlers: Record<string, TaskHandlerPluginConfig>, baseDir?: string): Promise<Error[]>;
    loadPlugin(plugin: TaskHandlerPlugin, baseDir?: string): Promise<void>;
    loadPlugins(plugins: TaskHandlerPlugin[], baseDir?: string): Promise<Error[]>;
    register(executable: string, handler: TaskHandler): void;
}

// @beta
export class TaskManager {
    constructor(pkg: BuildPackage, context: BuildContext, getTaskDefinition: (taskName: string) => TaskDefinition | undefined, dependentPackages: BuildGraphPackage[], buildGraphPackage: BuildGraphPackage, _getAllDefinedTaskNames?: (() => string[]) | undefined);
    createTasks(buildTaskNames: string[]): boolean | undefined;
    finalizeDependentTasks(): void;
    // (undocumented)
    protected readonly _getAllDefinedTaskNames?: (() => string[]) | undefined;
    getDependsOnTasks(_task: Task, taskName: string, pendingInitDep: Task[]): Task[];
    getMatchedTasks(deps: readonly string[], pendingInitDep?: Task[]): Task[];
    getScriptTask(taskName: string, pendingInitDep: Task[]): Task | undefined;
    getTask(taskName: string, pendingInitDep: Task[] | undefined): Task | undefined;
    resetAllTasks(): void;
    get scriptTasksMap(): ReadonlyMap<string, Task>;
    get taskCount(): number;
    get tasksMap(): ReadonlyMap<string, Task>;
}

// @beta
export type TaskName = string;

// @beta
export interface TaskOutputs {
    executionTimeMs: number;
    exitCode: number;
    files: ReadonlyArray<{
        readonly sourcePath: string;
        readonly relativePath: string;
        readonly hash?: string;
    }>;
    stderr: string;
    stdout: string;
}

// @internal (undocumented)
export class TaskStats {
    // (undocumented)
    leafBuiltCount: number;
    // (undocumented)
    leafExecTimeTotal: number;
    leafInitialUpToDateCount: number;
    leafLocalCacheHitCount: number;
    // (undocumented)
    leafQueueWaitTimeTotal: number;
    leafRemoteCacheHitCount: number;
    // (undocumented)
    leafTotalCount: number;
    // (undocumented)
    leafUpToDateCount: number;
}

// @internal (undocumented)
export interface WorkerExecResult {
    // (undocumented)
    code: number;
    // (undocumented)
    error?: Error;
    // (undocumented)
    memoryUsage?: NodeJS.MemoryUsage;
}

// @internal (undocumented)
export interface WorkerExecResultWithOutput extends WorkerExecResult {
    // (undocumented)
    stderr: string;
    // (undocumented)
    stdout: string;
}

// @internal (undocumented)
export class WorkerPool {
    constructor(useWorkerThreads: boolean, memoryUsageLimit: number);
    // (undocumented)
    reset(): void;
    // (undocumented)
    runOnWorker(workerName: string, command: string, cwd: string): Promise<WorkerExecResultWithOutput>;
    // (undocumented)
    readonly useWorkerThreads: boolean;
}

// (No @packageDocumentation comment for this package)

```
