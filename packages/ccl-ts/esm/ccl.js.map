{"version":3,"file":"ccl.js","sourceRoot":"","sources":["../src/ccl.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAIH;;;;;;;;;;;;;;;;GAgBG;AACH,MAAM,UAAU,KAAK,CAAC,IAAY;IACjC,wCAAwC;IACxC,sCAAsC;IACtC,OAAO,EAAE,CAAC;AACX,CAAC;AAED,+EAA+E;AAC/E,yCAAyC;AACzC,+EAA+E;AAC/E,qDAAqD;AACrD,uEAAuE;AACvE,mDAAmD;AAEnD,MAAM;AACN,oDAAoD;AACpD,KAAK;AACL,yEAAyE;AACzE,oEAAoE;AACpE,oDAAoD;AACpD,KAAK;AACL,qFAAqF;AACrF,uDAAuD;AACvD,MAAM;AACN,yDAAyD;AACzD,2CAA2C;AAC3C,IAAI;AAEJ,MAAM;AACN,oDAAoD;AACpD,KAAK;AACL,iEAAiE;AACjE,gFAAgF;AAChF,KAAK;AACL,8DAA8D;AAC9D,wCAAwC;AACxC,MAAM;AACN,gEAAgE;AAChE,2CAA2C;AAC3C,IAAI;AAEJ,MAAM;AACN,+CAA+C;AAC/C,KAAK;AACL,0CAA0C;AAC1C,+DAA+D;AAC/D,0DAA0D;AAC1D,MAAM;AACN,gFAAgF;AAChF,2CAA2C;AAC3C,IAAI;AAEJ,MAAM;AACN,iDAAiD;AACjD,KAAK;AACL,0CAA0C;AAC1C,yCAAyC;AACzC,mEAAmE;AACnE,MAAM;AACN,6EAA6E;AAC7E,2CAA2C;AAC3C,IAAI;AAEJ,MAAM;AACN,gDAAgD;AAChD,KAAK;AACL,0CAA0C;AAC1C,yCAAyC;AACzC,mEAAmE;AACnE,MAAM;AACN,+EAA+E;AAC/E,2CAA2C;AAC3C,IAAI;AAEJ,MAAM;AACN,8CAA8C;AAC9C,KAAK;AACL,0CAA0C;AAC1C,yCAAyC;AACzC,iEAAiE;AACjE,MAAM;AACN,+EAA+E;AAC/E,2CAA2C;AAC3C,IAAI;AAEJ,MAAM;AACN,6CAA6C;AAC7C,KAAK;AACL,0CAA0C;AAC1C,yCAAyC;AACzC,6DAA6D;AAC7D,MAAM;AACN,gFAAgF;AAChF,2CAA2C;AAC3C,IAAI;AAEJ,MAAM;AACN,0CAA0C;AAC1C,KAAK;AACL,4CAA4C;AAC5C,yEAAyE;AACzE,+BAA+B;AAC/B,MAAM;AACN,0BAA0B;AAC1B,qBAAqB;AACrB,yCAAyC;AACzC,eAAe;AACf,2CAA2C;AAC3C,IAAI;AAEJ,MAAM;AACN,gDAAgD;AAChD,KAAK;AACL,oCAAoC;AACpC,4DAA4D;AAC5D,+BAA+B;AAC/B,MAAM;AACN,sEAAsE;AACtE,2CAA2C;AAC3C,IAAI;AAEJ,MAAM;AACN,kCAAkC;AAClC,KAAK;AACL,4CAA4C;AAC5C,mCAAmC;AACnC,MAAM;AACN,oDAAoD;AACpD,2CAA2C;AAC3C,IAAI;AAEJ,MAAM;AACN,mDAAmD;AACnD,KAAK;AACL,iDAAiD;AACjD,uCAAuC;AACvC,MAAM;AACN,2DAA2D;AAC3D,2CAA2C;AAC3C,IAAI;AAEJ,MAAM;AACN,wDAAwD;AACxD,KAAK;AACL,8DAA8D;AAC9D,KAAK;AACL,yCAAyC;AACzC,wCAAwC;AACxC,MAAM;AACN,mDAAmD;AACnD,2CAA2C;AAC3C,IAAI;AAEJ,MAAM;AACN,sCAAsC;AACtC,KAAK;AACL,+CAA+C;AAC/C,2CAA2C;AAC3C,MAAM;AACN,qDAAqD;AACrD,2CAA2C;AAC3C,IAAI","sourcesContent":["/**\n * CCL (Categorical Configuration Language) parser implementation.\n *\n * This module provides the core parsing functionality for CCL.\n * See https://ccl.tylerbutler.com for the CCL specification.\n */\n\nimport type { Entry } from \"ccl-test-runner-ts/types\";\n\n/**\n * Parse CCL text into flat key-value entries.\n *\n * CCL is a simple configuration format where:\n * - Lines with `=` define key-value pairs\n * - Indented lines continue the previous value\n * - Keys are trimmed; values have leading/trailing spaces trimmed (tabs preserved)\n *\n * @param text - The CCL text to parse\n * @returns An array of entries with key-value pairs\n *\n * @example\n * ```typescript\n * const entries = parse(\"name = Alice\\nage = 42\");\n * // [{ key: \"name\", value: \"Alice\" }, { key: \"age\", value: \"42\" }]\n * ```\n */\nexport function parse(text: string): Entry[] {\n\t// TODO: Implement CCL parsing algorithm\n\t// For now, return empty array as stub\n\treturn [];\n}\n\n// ============================================================================\n// Future Functions (commented out stubs)\n// ============================================================================\n// Uncomment and implement these functions as needed.\n// Each function should be added to the test config in test/ccl.test.ts\n// and exported from src/index.ts when implemented.\n\n// /**\n//  * Parse CCL text with indentation normalization.\n//  *\n//  * Similar to `parse`, but first normalizes indentation by calculating\n//  * the common leading whitespace and stripping it from all lines.\n//  * This is similar to Python's `textwrap.dedent`.\n//  *\n//  * @param text - The CCL text to parse (with potentially inconsistent indentation)\n//  * @returns An array of entries with key-value pairs\n//  */\n// export function parseIndented(text: string): Entry[] {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Build a hierarchical object from flat entries.\n//  *\n//  * Takes a flat list of entries (from `parse`) and recursively\n//  * parses any nested CCL syntax in the values to build a hierarchical object.\n//  *\n//  * @param entries - The flat entries from a parse operation\n//  * @returns A hierarchical CCL object\n//  */\n// export function buildHierarchy(entries: Entry[]): CCLObject {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Get a string value at the specified path.\n//  *\n//  * @param obj - The CCL object to query\n//  * @param path - The path to the value (e.g., \"server.host\")\n//  * @returns The string value, or undefined if not found\n//  */\n// export function getString(obj: CCLObject, path: string): string | undefined {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Get an integer value at the specified path.\n//  *\n//  * @param obj - The CCL object to query\n//  * @param path - The path to the value\n//  * @returns The integer value, or undefined if not found/invalid\n//  */\n// export function getInt(obj: CCLObject, path: string): number | undefined {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Get a boolean value at the specified path.\n//  *\n//  * @param obj - The CCL object to query\n//  * @param path - The path to the value\n//  * @returns The boolean value, or undefined if not found/invalid\n//  */\n// export function getBool(obj: CCLObject, path: string): boolean | undefined {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Get a float value at the specified path.\n//  *\n//  * @param obj - The CCL object to query\n//  * @param path - The path to the value\n//  * @returns The float value, or undefined if not found/invalid\n//  */\n// export function getFloat(obj: CCLObject, path: string): number | undefined {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Get a list value at the specified path.\n//  *\n//  * @param obj - The CCL object to query\n//  * @param path - The path to the value\n//  * @returns The list of strings, or undefined if not found\n//  */\n// export function getList(obj: CCLObject, path: string): string[] | undefined {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Filter entries based on a predicate.\n//  *\n//  * @param entries - The entries to filter\n//  * @param predicate - A function that returns true for entries to keep\n//  * @returns Filtered entries\n//  */\n// export function filter(\n// \tentries: Entry[],\n// \tpredicate: (entry: Entry) => boolean,\n// ): Entry[] {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Compose two entry lists (overlay on base).\n//  *\n//  * @param base - The base entries\n//  * @param overlay - The overlay entries (take precedence)\n//  * @returns Composed entries\n//  */\n// export function compose(base: Entry[], overlay: Entry[]): Entry[] {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Print entries to CCL format.\n//  *\n//  * @param entries - The entries to format\n//  * @returns CCL-formatted string\n//  */\n// export function print(entries: Entry[]): string {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Format input to canonical CCL representation.\n//  *\n//  * @param input - The CCL text to canonicalize\n//  * @returns Canonicalized CCL string\n//  */\n// export function canonicalFormat(input: string): string {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Load and parse CCL from string directly to object.\n//  *\n//  * Convenience function combining parse and buildHierarchy.\n//  *\n//  * @param input - The CCL text to load\n//  * @returns A hierarchical CCL object\n//  */\n// export function load(input: string): CCLObject {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Round-trip: parse, build, print.\n//  *\n//  * @param input - The CCL text to round-trip\n//  * @returns The round-tripped CCL string\n//  */\n// export function roundTrip(input: string): string {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n"]}