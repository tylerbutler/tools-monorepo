{"version":3,"file":"ccl.js","sourceRoot":"","sources":["../src/ccl.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * CCL (Categorical Configuration Language) parser implementation.\n *\n * This module provides the core parsing functionality for CCL.\n * See https://ccl.tylerbutler.com for the CCL specification.\n */\n\nimport type { CCLObject, Entry } from \"ccl-test-runner-ts/types\";\n\n/**\n * Count leading whitespace characters (spaces and tabs).\n */\nfunction countIndentation(line: string): number {\n\tlet count = 0;\n\tfor (const char of line) {\n\t\tif (char === \" \" || char === \"\\t\") {\n\t\t\tcount++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}\n\n/**\n * Trim leading and trailing spaces only (preserving tabs).\n * This matches CCL behavior where tabs are preserved in values.\n */\nfunction trimSpacesOnly(str: string): string {\n\t// Trim leading spaces only (not tabs)\n\tlet start = 0;\n\twhile (start < str.length && str[start] === \" \") {\n\t\tstart++;\n\t}\n\n\t// Trim trailing spaces only (not tabs)\n\tlet end = str.length;\n\twhile (end > start && str[end - 1] === \" \") {\n\t\tend--;\n\t}\n\n\treturn str.slice(start, end);\n}\n\n/**\n * Parse CCL text into flat key-value entries.\n *\n * CCL is a simple configuration format where:\n * - Lines with `=` define key-value pairs\n * - Indented lines (more indentation than the entry start) continue the previous value\n * - Keys are trimmed; values have leading/trailing spaces trimmed\n * - Tabs in values are preserved\n *\n * @param text - The CCL text to parse\n * @returns An array of entries with key-value pairs\n *\n * @example\n * ```typescript\n * const entries = parse(\"name = Alice\\nage = 42\");\n * // [{ key: \"name\", value: \"Alice\" }, { key: \"age\", value: \"42\" }]\n * ```\n */\nexport function parse(text: string): Entry[] {\n\tconst entries: Entry[] = [];\n\n\t// Split on LF only; CR is treated as content per spec\n\tconst lines = text.split(\"\\n\");\n\n\t// Track the indentation level of the current entry\n\tlet currentEntryIndent = 0;\n\n\tfor (const line of lines) {\n\t\t// Skip empty lines\n\t\tif (line.length === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst lineIndent = countIndentation(line);\n\n\t\t// Find first equals sign (split on first = only)\n\t\tconst eqIndex = line.indexOf(\"=\");\n\n\t\t// Check if this is a continuation line:\n\t\t// - Must have previous entry\n\t\t// - Must have more indentation than the entry's starting line\n\t\t// - OR has no equals sign (implicit continuation)\n\t\tconst prev = entries[entries.length - 1];\n\t\tif (prev !== undefined && lineIndent > currentEntryIndent) {\n\t\t\t// This is a continuation line - append to previous value\n\t\t\tprev.value = prev.value + \"\\n\" + line;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (eqIndex === -1) {\n\t\t\t// No equals sign and not a continuation - append to previous if exists\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev.value = prev.value + \"\\n\" + line;\n\t\t\t}\n\t\t\t// If no previous entry, ignore the line (invalid CCL)\n\t\t\tcontinue;\n\t\t}\n\n\t\t// New entry - extract key and value\n\t\tconst rawKey = line.slice(0, eqIndex);\n\t\tconst rawValue = line.slice(eqIndex + 1);\n\n\t\t// Key: trim whitespace on both sides\n\t\tconst key = rawKey.trim();\n\n\t\t// Value: trim leading/trailing spaces (preserving tabs)\n\t\tconst value = trimSpacesOnly(rawValue);\n\n\t\tentries.push({ key, value });\n\n\t\t// Track the indentation of this entry's starting line\n\t\tcurrentEntryIndent = lineIndent;\n\t}\n\n\treturn entries;\n}\n\n/**\n * Build a hierarchical object from flat entries.\n *\n * Takes a flat list of entries (from `parse`) and recursively\n * parses any nested CCL syntax in the values to build a hierarchical object.\n *\n * The algorithm uses recursive fixed-point parsing:\n * - If a value contains '=', it's recursively parsed as CCL\n * - If a value has no '=', it's stored as a terminal string\n * - Empty keys ('') indicate list items\n *\n * @param entries - The flat entries from a parse operation\n * @returns A hierarchical CCL object\n *\n * @example\n * ```typescript\n * const entries = parse(\"server =\\n  host = localhost\\n  port = 8080\");\n * const obj = buildHierarchy(entries);\n * // { server: { host: \"localhost\", port: \"8080\" } }\n * ```\n */\nexport function buildHierarchy(entries: Entry[]): CCLObject {\n\tconst result: CCLObject = {};\n\tconst listItems: string[] = [];\n\n\tfor (const entry of entries) {\n\t\tconst { key, value } = entry;\n\n\t\tif (key === \"\") {\n\t\t\t// Empty key = list item\n\t\t\tlistItems.push(value);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check if value contains nested CCL (has an equals sign)\n\t\tif (value.includes(\"=\")) {\n\t\t\t// Recursively parse the value\n\t\t\tconst nestedEntries = parse(value);\n\t\t\tconst nestedObject = buildHierarchy(nestedEntries);\n\t\t\tresult[key] = nestedObject;\n\t\t} else {\n\t\t\t// Terminal value - store as string\n\t\t\tresult[key] = value;\n\t\t}\n\t}\n\n\t// If we collected list items, add them under a special key or return as-is\n\t// Per CCL spec, list items without keys become an array\n\tif (listItems.length > 0) {\n\t\t// If there's only list items and no other keys, the behavior depends on context\n\t\t// For now, store them as an array under the empty string key\n\t\t// This matches how CCL handles lists at the top level\n\t\tresult[\"\"] = listItems;\n\t}\n\n\treturn result;\n}\n\n// ============================================================================\n// Future Functions (commented out stubs)\n// ============================================================================\n// Uncomment and implement these functions as needed.\n// Each function should be added to the test config in test/ccl.test.ts\n// and exported from src/index.ts when implemented.\n\n// /**\n//  * Parse CCL text with indentation normalization.\n//  *\n//  * Similar to `parse`, but first normalizes indentation by calculating\n//  * the common leading whitespace and stripping it from all lines.\n//  * This is similar to Python's `textwrap.dedent`.\n//  *\n//  * @param text - The CCL text to parse (with potentially inconsistent indentation)\n//  * @returns An array of entries with key-value pairs\n//  */\n// export function parseIndented(text: string): Entry[] {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Build a hierarchical object from flat entries.\n//  *\n//  * Takes a flat list of entries (from `parse`) and recursively\n//  * parses any nested CCL syntax in the values to build a hierarchical object.\n//  *\n//  * @param entries - The flat entries from a parse operation\n//  * @returns A hierarchical CCL object\n//  */\n// export function buildHierarchy(entries: Entry[]): CCLObject {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Get a string value at the specified path.\n//  *\n//  * @param obj - The CCL object to query\n//  * @param path - The path to the value (e.g., \"server.host\")\n//  * @returns The string value, or undefined if not found\n//  */\n// export function getString(obj: CCLObject, path: string): string | undefined {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Get an integer value at the specified path.\n//  *\n//  * @param obj - The CCL object to query\n//  * @param path - The path to the value\n//  * @returns The integer value, or undefined if not found/invalid\n//  */\n// export function getInt(obj: CCLObject, path: string): number | undefined {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Get a boolean value at the specified path.\n//  *\n//  * @param obj - The CCL object to query\n//  * @param path - The path to the value\n//  * @returns The boolean value, or undefined if not found/invalid\n//  */\n// export function getBool(obj: CCLObject, path: string): boolean | undefined {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Get a float value at the specified path.\n//  *\n//  * @param obj - The CCL object to query\n//  * @param path - The path to the value\n//  * @returns The float value, or undefined if not found/invalid\n//  */\n// export function getFloat(obj: CCLObject, path: string): number | undefined {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Get a list value at the specified path.\n//  *\n//  * @param obj - The CCL object to query\n//  * @param path - The path to the value\n//  * @returns The list of strings, or undefined if not found\n//  */\n// export function getList(obj: CCLObject, path: string): string[] | undefined {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Filter entries based on a predicate.\n//  *\n//  * @param entries - The entries to filter\n//  * @param predicate - A function that returns true for entries to keep\n//  * @returns Filtered entries\n//  */\n// export function filter(\n// \tentries: Entry[],\n// \tpredicate: (entry: Entry) => boolean,\n// ): Entry[] {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Compose two entry lists (overlay on base).\n//  *\n//  * @param base - The base entries\n//  * @param overlay - The overlay entries (take precedence)\n//  * @returns Composed entries\n//  */\n// export function compose(base: Entry[], overlay: Entry[]): Entry[] {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Print entries to CCL format.\n//  *\n//  * @param entries - The entries to format\n//  * @returns CCL-formatted string\n//  */\n// export function print(entries: Entry[]): string {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Format input to canonical CCL representation.\n//  *\n//  * @param input - The CCL text to canonicalize\n//  * @returns Canonicalized CCL string\n//  */\n// export function canonicalFormat(input: string): string {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Load and parse CCL from string directly to object.\n//  *\n//  * Convenience function combining parse and buildHierarchy.\n//  *\n//  * @param input - The CCL text to load\n//  * @returns A hierarchical CCL object\n//  */\n// export function load(input: string): CCLObject {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n\n// /**\n//  * Round-trip: parse, build, print.\n//  *\n//  * @param input - The CCL text to round-trip\n//  * @returns The round-tripped CCL string\n//  */\n// export function roundTrip(input: string): string {\n// \tthrow new Error(\"Not yet implemented\");\n// }\n"]}