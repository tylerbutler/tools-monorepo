{"version":3,"file":"workspace.js","sourceRoot":"","sources":["../src/workspace.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as path from \"node:path\";\n\nimport execa from \"execa\";\nimport resolveWorkspacePkg from \"resolve-workspace-root\";\nimport { globSync } from \"tinyglobby\";\n\nconst { getWorkspaceGlobs, resolveWorkspaceRoot } = resolveWorkspacePkg;\n\nimport type { ReleaseGroupDefinition, WorkspaceDefinition } from \"./config.js\";\nimport { loadPackageFromWorkspaceDefinition } from \"./package.js\";\nimport { detectPackageManager } from \"./packageManagers.js\";\nimport { ReleaseGroup } from \"./releaseGroup.js\";\nimport type {\n\tIBuildProject,\n\tIPackage,\n\tIPackageManager,\n\tIReleaseGroup,\n\tIWorkspace,\n\tReleaseGroupName,\n\tWorkspaceName,\n} from \"./types.js\";\nimport { WriteOnceMap } from \"./writeOnceMap.js\";\n\n/**\n * {@inheritDoc IWorkspace}\n */\nexport class Workspace implements IWorkspace {\n\t/**\n\t * {@inheritDoc IWorkspace.name}\n\t */\n\tpublic readonly name: WorkspaceName;\n\n\t/**\n\t * {@inheritDoc IWorkspace.releaseGroups}\n\t */\n\tpublic readonly releaseGroups: Map<ReleaseGroupName, IReleaseGroup>;\n\n\t/**\n\t * {@inheritDoc IWorkspace.rootPackage}\n\t */\n\tpublic readonly rootPackage: IPackage;\n\n\t/**\n\t * {@inheritDoc IWorkspace.packages}\n\t */\n\tpublic readonly packages: IPackage[];\n\n\t/**\n\t * {@inheritDoc IWorkspace.directory}\n\t */\n\tpublic readonly directory: string;\n\n\t/**\n\t * {@inheritDoc IWorkspace.packageManager}\n\t */\n\tpublic readonly packageManager: IPackageManager;\n\n\t/**\n\t * Construct a new workspace object.\n\t *\n\t * @param name - The name of the workspace.\n\t * @param definition - The definition of the workspace.\n\t * @param root - The path to the root of the workspace.\n\t */\n\tprivate constructor(\n\t\tname: string,\n\t\tdefinition: WorkspaceDefinition,\n\t\troot: string,\n\n\t\t/**\n\t\t * {@inheritDoc IWorkspace.buildProject}\n\t\t */\n\t\tpublic readonly buildProject: IBuildProject,\n\t) {\n\t\tthis.name = name as WorkspaceName;\n\t\tthis.directory = path.resolve(root, definition.directory);\n\n\t\t// Find the workspace root\n\t\tconst foundWorkspaceRootPath = resolveWorkspaceRoot(this.directory);\n\t\tif (foundWorkspaceRootPath === null) {\n\t\t\tthrow new Error(\n\t\t\t\t`Could not find a workspace root. Started looking at '${this.directory}'.`,\n\t\t\t);\n\t\t} else if (foundWorkspaceRootPath !== this.directory) {\n\t\t\t// This is a sanity check. directory is the path passed in when creating the Workspace object, while rootDir is\n\t\t\t// the dir that `getPackagesSync` found. They should be the same.\n\t\t\tthrow new Error(\n\t\t\t\t`The root dir found by resolve-workspace-root, '${foundWorkspaceRootPath}', does not match the configured directory '${this.directory}'`,\n\t\t\t);\n\t\t}\n\n\t\tthis.packageManager = detectPackageManager(foundWorkspaceRootPath);\n\n\t\tconst rootPackageJsonPath = path.join(this.directory, \"package.json\");\n\t\tconst workspaceGlobs = getWorkspaceGlobs(foundWorkspaceRootPath);\n\t\tif (workspaceGlobs === null) {\n\t\t\tthrow new Error(`Couldn't find workspace globs.`);\n\t\t}\n\n\t\tconst packageGlobs = workspaceGlobs.map((g) => `${g}/package.json`);\n\t\tconst packageJsonPaths = globSync(packageGlobs, {\n\t\t\tcwd: foundWorkspaceRootPath,\n\t\t\tignore: [\"**/node_modules/**\"],\n\t\t\tonlyFiles: true,\n\t\t\tabsolute: true,\n\t\t});\n\n\t\t// Load the workspace root IPackage\n\t\t// this.rootPackage = loadPackageFromWorkspaceDefinition(\n\t\t// \tpath.join(foundRoot, \"package.json\"),\n\t\t// \t/* isWorkspaceRoot */ true,\n\t\t// \tdefinition,\n\t\t// \tthis,\n\t\t// );\n\t\t// this.packages.unshift(this.rootPackage);\n\n\t\tthis.packages = [];\n\n\t\t// Load all the workspace packages\n\t\t// if (this.packages.length > 1) {\n\t\tfor (const pkgJsonPath of packageJsonPaths) {\n\t\t\tconst isWorkspaceRoot = pkgJsonPath === rootPackageJsonPath;\n\n\t\t\t// Add all packages except the root; we'll add it after the other packages.\n\t\t\tif (!isWorkspaceRoot) {\n\t\t\t\tconst loadedPackage = loadPackageFromWorkspaceDefinition(\n\t\t\t\t\tpkgJsonPath,\n\t\t\t\t\t/* isWorkspaceRoot */ false,\n\t\t\t\t\tdefinition,\n\t\t\t\t\tthis,\n\t\t\t\t);\n\t\t\t\tthis.packages.push(loadedPackage);\n\t\t\t}\n\t\t}\n\n\t\tthis.rootPackage = loadPackageFromWorkspaceDefinition(\n\t\t\trootPackageJsonPath,\n\t\t\t/* isWorkspaceRoot */ true,\n\t\t\tdefinition,\n\t\t\tthis,\n\t\t);\n\n\t\tif (this.rootPackage === undefined) {\n\t\t\tthrow new Error(`No root package found for workspace in '${foundWorkspaceRootPath}'`);\n\t\t}\n\n\t\t// Prepend the root package to the package list.\n\t\tthis.packages.unshift(this.rootPackage);\n\n\t\tconst rGroupDefinitions: Map<ReleaseGroupName, ReleaseGroupDefinition> =\n\t\t\tdefinition.releaseGroups === undefined\n\t\t\t\t? new WriteOnceMap<ReleaseGroupName, ReleaseGroupDefinition>()\n\t\t\t\t: new WriteOnceMap(\n\t\t\t\t\t\tObject.entries(definition.releaseGroups).map(([rgName, group]) => {\n\t\t\t\t\t\t\treturn [rgName as ReleaseGroupName, group];\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\n\t\tthis.releaseGroups = new Map();\n\t\tfor (const [groupName, def] of rGroupDefinitions) {\n\t\t\tconst newGroup = new ReleaseGroup(groupName, def, this);\n\t\t\tthis.releaseGroups.set(groupName, newGroup);\n\t\t}\n\n\t\t// sanity check - make sure that all packages are in a release group.\n\t\tconst noGroup = new Set(this.packages.map((p) => p.name));\n\t\tfor (const group of this.releaseGroups.values()) {\n\t\t\tfor (const pkg of group.packages) {\n\t\t\t\tnoGroup.delete(pkg.name);\n\t\t\t}\n\t\t}\n\n\t\tif (noGroup.size > 0) {\n\t\t\tconst packageList = [...noGroup].join(\"\\n\");\n\t\t\tconst message = `Found packages in the ${name} workspace that are not in any release groups. Check your config.\\n${packageList}`;\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc Installable.checkInstall}\n\t */\n\tpublic async checkInstall(): Promise<true | string[]> {\n\t\tconst errors: string[] = [];\n\t\tfor (const buildPackage of this.packages) {\n\t\t\tconst installed = await buildPackage.checkInstall();\n\t\t\tif (installed !== true) {\n\t\t\t\terrors.push(...installed);\n\t\t\t}\n\t\t}\n\n\t\tif (errors.length > 0) {\n\t\t\treturn errors;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * The package manager used to manage this package. This is an async operation.\n\t */\n\t// async getPackageManager(): Promise<IPackageManager> {\n\t// \tconst r = await detectPackageManager(this.directory);\n\t// \tif (r === undefined) {\n\t// \t\tthrow new Error(\"No package manager found.\");\n\t// \t}\n\n\t// \tif (r.warnings !== undefined) {\n\t// \t\tthrow new Error(r.warnings.join(\"/n\"));\n\t// \t}\n\t// \treturn r;\n\t// }\n\n\t/**\n\t * {@inheritDoc Installable.install}\n\t */\n\t/**\n\t * {@inheritDoc Installable.install}\n\t */\n\tpublic async install(updateLockfile: boolean): Promise<boolean> {\n\t\tconst commandArgs = this.packageManager.getInstallCommandWithArgs(updateLockfile);\n\n\t\tconst output = await execa(this.packageManager.name.toString(), commandArgs, {\n\t\t\tcwd: this.directory,\n\t\t});\n\n\t\tif (output.exitCode !== 0) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Synchronously reload all of the packages in the workspace.\n\t */\n\tpublic reload(): void {\n\t\tfor (const pkg of this.packages) {\n\t\t\tpkg.reload();\n\t\t}\n\t}\n\n\tpublic toString(): string {\n\t\treturn `${this.name} (WORKSPACE)`;\n\t}\n\n\t/**\n\t * Load a workspace from a {@link WorkspaceDefinition}.\n\t *\n\t * @param name - The name of the workspace.\n\t * @param definition - The definition for the workspace.\n\t * @param root - The path to the root of the workspace.\n\t * @param buildProject - The build project that the workspace belongs to.\n\t * @returns A loaded {@link IWorkspace}.\n\t */\n\tpublic static load(\n\t\tname: string,\n\t\tdefinition: WorkspaceDefinition,\n\t\troot: string,\n\t\tbuildProject: IBuildProject,\n\t): IWorkspace {\n\t\tconst workspace = new Workspace(name, definition, root, buildProject);\n\t\treturn workspace;\n\t}\n}\n"]}