{"version":3,"file":"packageJsonUtils.js","sourceRoot":"","sources":["../src/packageJsonUtils.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,EAAE,YAAY,EAAE,MAAM,SAAS,CAAC;AACvC,OAAO,EAAE,QAAQ,EAAE,MAAM,kBAAkB,CAAC;AAC5C,OAAO,KAAK,IAAI,MAAM,WAAW,CAAC;AAElC,OAAO,YAAY,MAAM,eAAe,CAAC;AACzC,OAAO,MAAM,MAAM,UAAU,CAAC;AAC9B,gHAAgH;AAChH,MAAM,EAAE,SAAS,EAAE,aAAa,EAAE,GAAG,MAAM,CAAC;AAC5C,OAAO,eAAe,MAAM,mBAAmB,CAAC;AAIhD;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,qBAAqB,CACpC,WAAmB,EACnB,kBAAqC;IAErC,MAAM,YAAY,GAAG,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC;QACxD,CAAC,CAAC,WAAW;QACb,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;IAC1C,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,GAAG,wBAAwB,CAAI,YAAY,CAAC,CAAC;IAEpE,6BAA6B;IAC7B,kBAAkB,CAAC,OAAO,CAAC,CAAC;IAE5B,gBAAgB,CAAC,YAAY,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;AACjD,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,wBAAwB,CACvC,UAAkB;IAElB,MAAM,QAAQ,GAAG,YAAY,CAAC,UAAU,CAAC,CAAC,QAAQ,EAAE,CAAC;IACrD,MAAM,WAAW,GAAG,YAAY,CAAC,QAAQ,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC;IAC1D,MAAM,OAAO,GAAM,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAM,CAAC;IAC7C,OAAO,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;AAC/B,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,gBAAgB,CAC/B,WAAmB,EACnB,OAAU,EACV,MAAc;IAEd,OAAO,aAAa,CAAC,WAAW,EAAE,eAAe,CAAC,OAAO,CAAC,EAAE,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC;AACjF,CAAC;AAED;;;;;;;;;;;GAWG;AACH,MAAM,CAAC,KAAK,UAAU,0BAA0B,CAC/C,WAAmB,EACnB,kBAA8C;IAE9C,MAAM,YAAY,GAAG,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC;QACxD,CAAC,CAAC,WAAW;QACb,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;IAC1C,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,GAAG,MAAM,6BAA6B,CAAI,YAAY,CAAC,CAAC;IAE/E,6BAA6B;IAC7B,MAAM,kBAAkB,CAAC,OAAO,CAAC,CAAC;IAElC,MAAM,SAAS,CAAC,YAAY,EAAE,eAAe,CAAC,OAAO,CAAC,EAAE,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC;AAC7E,CAAC;AAED;;;GAGG;AACH,KAAK,UAAU,6BAA6B,CAC3C,UAAkB;IAElB,OAAO,QAAQ,CAAC,UAAU,EAAE,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,EAAE;QACnE,MAAM,WAAW,GAAG,YAAY,CAAC,QAAQ,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC;QAC1D,MAAM,OAAO,GAAM,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAM,CAAC;QAC7C,OAAO,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;IAC/B,CAAC,CAAC,CAAC;AACJ,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { readFileSync } from \"node:fs\";\nimport { readFile } from \"node:fs/promises\";\nimport * as path from \"node:path\";\n\nimport detectIndent from \"detect-indent\";\nimport fsePkg from \"fs-extra\";\n// eslint-disable-next-line import/no-named-as-default-member -- Imports are written this way for CJS/ESM compat\nconst { writeJson, writeJsonSync } = fsePkg;\nimport sortPackageJson from \"sort-package-json\";\n\nimport type { PackageJson } from \"./types.js\";\n\n/**\n * Reads the contents of package.json, applies a transform function to it, then writes the results back to the source\n * file.\n *\n * @param packagePath - A path to a package.json file or a folder containing one. If the path is a directory, the\n * package.json from that directory will be used.\n * @param packageTransformer - A function that will be executed on the package.json contents before writing it\n * back to the file.\n *\n * @remarks\n *\n * The package.json is always sorted using sort-package-json.\n */\nexport function updatePackageJsonFile<J extends PackageJson = PackageJson>(\n\tpackagePath: string,\n\tpackageTransformer: (json: J) => void,\n): void {\n\tconst resolvedPath = packagePath.endsWith(\"package.json\")\n\t\t? packagePath\n\t\t: path.join(packagePath, \"package.json\");\n\tconst [pkgJson, indent] = readPackageJsonAndIndent<J>(resolvedPath);\n\n\t// Transform the package.json\n\tpackageTransformer(pkgJson);\n\n\twritePackageJson(resolvedPath, pkgJson, indent);\n}\n\n/**\n * Reads a package.json file from a path, detects its indentation, and returns both the JSON as an object and\n * indentation.\n */\nexport function readPackageJsonAndIndent<J extends PackageJson = PackageJson>(\n\tpathToJson: string,\n): [json: J, indent: string] {\n\tconst contents = readFileSync(pathToJson).toString();\n\tconst indentation = detectIndent(contents).indent || \"\\t\";\n\tconst pkgJson: J = JSON.parse(contents) as J;\n\treturn [pkgJson, indentation];\n}\n\n/**\n * Writes a PackageJson object to a file using the provided indentation.\n */\nexport function writePackageJson<J extends PackageJson = PackageJson>(\n\tpackagePath: string,\n\tpkgJson: J,\n\tindent: string,\n): void {\n\treturn writeJsonSync(packagePath, sortPackageJson(pkgJson), { spaces: indent });\n}\n\n/**\n * Reads the contents of package.json, applies a transform function to it, then writes\n * the results back to the source file.\n *\n * @param packagePath - A path to a package.json file or a folder containing one. If the\n * path is a directory, the package.json from that directory will be used.\n * @param packageTransformer - A function that will be executed on the package.json\n * contents before writing it back to the file.\n *\n * @remarks\n * The package.json is always sorted using sort-package-json.\n */\nexport async function updatePackageJsonFileAsync<J extends PackageJson = PackageJson>(\n\tpackagePath: string,\n\tpackageTransformer: (json: J) => Promise<void>,\n): Promise<void> {\n\tconst resolvedPath = packagePath.endsWith(\"package.json\")\n\t\t? packagePath\n\t\t: path.join(packagePath, \"package.json\");\n\tconst [pkgJson, indent] = await readPackageJsonAndIndentAsync<J>(resolvedPath);\n\n\t// Transform the package.json\n\tawait packageTransformer(pkgJson);\n\n\tawait writeJson(resolvedPath, sortPackageJson(pkgJson), { spaces: indent });\n}\n\n/**\n * Reads a package.json file from a path, detects its indentation, and returns both the JSON as an object and\n * indentation.\n */\nasync function readPackageJsonAndIndentAsync<J extends PackageJson = PackageJson>(\n\tpathToJson: string,\n): Promise<[json: J, indent: string]> {\n\treturn readFile(pathToJson, { encoding: \"utf8\" }).then((contents) => {\n\t\tconst indentation = detectIndent(contents).indent || \"\\t\";\n\t\tconst pkgJson: J = JSON.parse(contents) as J;\n\t\treturn [pkgJson, indentation];\n\t});\n}\n"]}