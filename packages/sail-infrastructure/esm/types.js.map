{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAgRH;;GAEG;AACH,MAAM,UAAU,eAAe;AAC9B,8DAA8D;AAC9D,OAAuE;IAEvE,IAAI,CAAC,CAAC,MAAM,IAAI,OAAO,CAAC,EAAE,CAAC;QAC1B,OAAO,KAAK,CAAC;IACd,CAAC;IAED,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;QACjC,kHAAkH;QAClH,gBAAgB;QAChB,OAAO,WAAW,IAAI,OAAO,IAAI,UAAU,IAAI,OAAO,CAAC;IACxD,CAAC;IAED,OAAO,KAAK,CAAC;AACd,CAAC;AAoKD;;GAEG;AACH,yIAAyI;AACzI,MAAM,UAAU,UAAU,CAAC,GAAQ;IAClC,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,CAAC;QAC7B,OAAO,WAAW,IAAI,GAAG,CAAC;IAC3B,CAAC;IACD,OAAO,KAAK,CAAC;AACd,CAAC","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport type { Agent, AgentName } from \"package-manager-detector\";\nimport { SimpleGit } from \"simple-git\";\nimport type { Opaque, SetRequired, PackageJson as StandardPackageJson } from \"type-fest\";\n\nimport type { BuildProjectConfig } from \"./config.js\";\n\n/**\n * Extra package.json fields used by pnpm.\n * See {@link https://pnpm.io/package_json}.\n */\nexport interface PnpmPackageJsonFields {\n\t/**\n\t * Configuration for pnpm.\n\t * See {@link https://pnpm.io/package_json}.\n\t */\n\tpnpm?: {\n\t\t/**\n\t\t * Instruct pnpm to override any dependency in the dependency graph.\n\t\t * See {@link https://pnpm.io/package_json#pnpmoverrides}\n\t\t */\n\t\toverrides?: Record<string, string>;\n\t};\n}\n\n/**\n * All known package.json fields including those that are specific to build-infrastructure.\n * The `name`, `scripts`, and `version` fields are required, unlike standard package.json.\n */\nexport type PackageJson = SetRequired<\n\tPick<\n\t\tStandardPackageJson,\n\t\t| \"name\"\n\t\t| \"scripts\"\n\t\t| \"version\"\n\t\t| \"dependencies\"\n\t\t| \"devDependencies\"\n\t\t| \"peerDependencies\"\n\t\t| \"private\"\n\t\t| \"type\"\n\t>,\n\t\"name\" | \"scripts\" | \"version\"\n> &\n\tPnpmPackageJsonFields;\n\n/**\n * Additional properties that can be added to an {@link IPackage}.\n */\nexport type AdditionalPackageProps = Record<string, string> | undefined;\n\n/**\n * A BuildProject organizes a collection of npm packages into workspaces and release groups. A BuildProject can contain\n * multiple workspaces, and a workspace can in turn contain multiple release groups. Both workspaces and release groups\n * represent ways to organize packages in the repo, but their purpose and function are different.\n *\n * See {@link IWorkspace} and {@link IReleaseGroup} for more details.\n *\n * @typeParam P - The type of {@link IPackage} the repo uses. This can be any type that implements {@link IPackage}.\n */\nexport interface IBuildProject<P extends IPackage = IPackage> extends Reloadable {\n\t/**\n\t * The absolute path to the root of the IBuildProject. This is the path where the config file is located.\n\t */\n\troot: string;\n\n\t/**\n\t * A map of all workspaces in the BuildProject.\n\t */\n\tworkspaces: ReadonlyMap<WorkspaceName, IWorkspace>;\n\n\t/**\n\t * A map of all release groups in the BuildProject.\n\t */\n\treleaseGroups: ReadonlyMap<ReleaseGroupName, IReleaseGroup>;\n\n\t/**\n\t * A map of all packages in the BuildProject.\n\t */\n\tpackages: ReadonlyMap<PackageName, P>;\n\n\t/**\n\t * A partial URL to the upstream (remote) repo. This can be set to the name of the repo on GitHub. For example,\n\t * \"microsoft/FluidFramework\".\n\t */\n\tupstreamRemotePartialUrl?: string;\n\n\t/**\n\t * The configuration for the build project.\n\t */\n\tconfiguration: BuildProjectConfig;\n\n\t/**\n\t * The source for the configuration. If the configuration is loaded from a file, this will be the path to the file. If\n\t * the configuration is inferred, this will be the string \"INFERRED\".\n\t */\n\tconfigurationSource: string | \"INFERRED\";\n\n\t/**\n\t * Transforms an absolute path to a path relative to the IBuildProject root.\n\t *\n\t * @param p - The path to make relative to the IBuildProject root.\n\t * @returns The path relative to the IBuildProject root.\n\t */\n\trelativeToRepo(p: string): string;\n\n\t/**\n\t * If the BuildProject is within a Git repository, this function will return a SimpleGit instance rooted at the root\n\t * of the Git repository. If the BuildProject is _not_ within a Git repository, this function will throw a\n\t * {@link NotInGitRepository} error.\n\t *\n\t * @throws A {@link NotInGitRepository} error if the path is not within a Git repository.\n\t */\n\tgetGitRepository(): Promise<Readonly<SimpleGit>>;\n\n\t/**\n\t * Returns the {@link IReleaseGroup} associated with a package.\n\t */\n\tgetPackageReleaseGroup(pkg: Readonly<P>): Readonly<IReleaseGroup>;\n}\n\n/**\n * A common interface for installable things, like packages, release groups, and workspaces.\n */\nexport interface Installable {\n\t/**\n\t * Returns `true` if the item is installed. If the item is not installed, an array of error strings will be returned.\n\t */\n\tcheckInstall(): Promise<true | string[]>;\n\n\t/**\n\t * Installs the item.\n\t *\n\t * @param updateLockfile - If true, the lockfile will be updated. Otherwise, the lockfile will not be updated. This\n\t * may cause the installation to fail and this function to throw an error.\n\t *\n\t * @throws An error if `updateLockfile` is false and the lockfile is outdated.\n\t */\n\tinstall(updateLockfile: boolean): Promise<boolean>;\n}\n\n/**\n * An interface for things that can be reloaded,\n */\nexport interface Reloadable {\n\t/**\n\t * Synchronously reload.\n\t */\n\treload(): void;\n}\n\n/**\n * A tagged type representing workspace names.\n */\nexport type WorkspaceName = Opaque<string, \"WorkspaceName\">;\n\n/**\n * A workspace is a collection of packages, including a root package, that is managed using a package manager's\n * \"workspaces\" functionality. A BuildProject can contain multiple workspaces. Workspaces are defined and managed using\n * the package manager directly. A BuildProject builds on top of workspaces and relies on the package manager to install\n * and manage dependencies and interdependencies within the workspace.\n *\n * A workspace defines the _physical layout_ of the packages within it. Workspaces are a generally a feature provided by\n * the package manager (npm, yarn, pnpm, etc.). A workspace is rooted in a particular folder, and uses the configuration\n * within that folder to determine what packages it contains. The configuration used is specific to the package manager.\n *\n * The workspace is also the boundary at which dependencies are installed and managed. When you install dependencies for\n * a package in a workspace, all dependencies for all packages in the workspace will be installed. Within a workspace,\n * it is trivial to link multiple packages so they can depend on one another. The `IWorkspace` type is a thin wrapper on\n * top of these package manager features.\n *\n * A BuildProject will only load packages identified by the package manager's workspace feature. That is, any package in\n * the repo that is not configured as part of a workspace is invisible to tools using the BuildProject.\n *\n * Workspaces are not involved in versioning or releasing packages. They are used for dependency management only.\n * Release groups, on the other hand, are used to group packages into releasable groups. See {@link IReleaseGroup} for\n * more information.\n */\nexport interface IWorkspace extends Installable, Reloadable {\n\t/**\n\t * The name of the workspace.\n\t */\n\tname: WorkspaceName;\n\n\t/**\n\t * The absolute path to the root directory of the workspace. This directory will contain the workspace root package.\n\t */\n\tdirectory: string;\n\n\t/**\n\t * The root package of the workspace.\n\t */\n\trootPackage: IPackage;\n\n\t/**\n\t * A map of all the release groups in the workspace.\n\t */\n\treleaseGroups: Map<ReleaseGroupName, IReleaseGroup>;\n\n\t/**\n\t * The build project that the workspace belongs to.\n\t */\n\tbuildProject: IBuildProject;\n\n\t/**\n\t * An array of all the packages in the workspace. This includes the workspace root and any release group roots and\n\t * constituent packages as well.\n\t */\n\tpackages: IPackage[];\n\n\t/**\n\t * The package manager used to manage this workspace.\n\t */\n\tpackageManager: IPackageManager;\n\n\ttoString(): string;\n}\n\n/**\n * A tagged type representing release group names.\n */\nexport type ReleaseGroupName = Opaque<string, \"IReleaseGroup\">;\n\n/**\n * A release group is a collection of packages that are versioned and released together. All packages within a release\n * group will have the same version, and all packages will be released at the same time.\n *\n * Release groups are not involved in dependency management. They are used for versioning and releasing packages only.\n * Workspaces, on the other hand, are used to manage dependencies and interdependencies. See {@link IWorkspace} for more\n * information.\n */\nexport interface IReleaseGroup extends Reloadable {\n\t/**\n\t * The name of the release group. All release groups must have unique names.\n\t */\n\treadonly name: ReleaseGroupName;\n\n\t/**\n\t * The version of the release group.\n\t */\n\treadonly version: string;\n\n\t/**\n\t * The package that is the release group root, if one exists.\n\t */\n\treadonly rootPackage?: IPackage;\n\n\t/**\n\t * An array of all packages in the release group.\n\t */\n\treadonly packages: IPackage[];\n\n\t/**\n\t * The workspace that the release group belongs to.\n\t */\n\treadonly workspace: IWorkspace;\n\n\t/**\n\t * An array of all the release groups that the release group depends on. If any package in a release group has any\n\t * dependency on a package in another release group within the same workspace, then the first release group depends\n\t * on the second.\n\t */\n\treadonly releaseGroupDependencies: IReleaseGroup[];\n\n\t/**\n\t * An optional ADO pipeline URL for the CI pipeline that builds the release group.\n\t */\n\treadonly adoPipelineUrl?: string;\n\n\ttoString(): string;\n}\n\n/**\n * A type guard that returns `true` if the checked item is an {@link IReleaseGroup}.\n */\nexport function isIReleaseGroup(\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\ttoCheck: Exclude<any, string | number | ReleaseGroupName | PackageName>,\n): toCheck is IReleaseGroup {\n\tif (!(\"name\" in toCheck)) {\n\t\treturn false;\n\t}\n\n\tif (typeof toCheck === \"object\") {\n\t\t// TODO: is there a better way to implement a type guard than unique names of properties? Maybe something with the\n\t\t// opaque types?\n\t\treturn \"workspace\" in toCheck && \"packages\" in toCheck;\n\t}\n\n\treturn false;\n}\n\n/**\n * Known package managers supported by build-infrastructure.\n */\nexport type PackageManagerName = AgentName;\n\n/**\n * For package managers that have multiple versions or flavors, this type contains the unambiguous string that can be\n * used to install the package manager.\n *\n * For example, \"yarn\" is yarn 1, while \"yarn\\@berry\" is yarn's new version.\n */\nexport type PackageManagerInstallName = Agent;\n\n/**\n * A package manager, such as \"npm\" or \"pnpm\".\n */\nexport interface IPackageManager {\n\t/**\n\t * The name of the package manager.\n\t */\n\treadonly name: PackageManagerName;\n\n\t/**\n\t * The name of the lockfile(s) used by the package manager.\n\t */\n\treadonly lockfileNames: string[];\n\n\t/**\n\t * Returns an array of arguments, including the name of the command, e.g. \"install\", that can be used to install\n\t * dependencies using this package manager.\n\t *\n\t * @param updateLockfile - If `true`, then the returned command will include flags or arguments necessary to update\n\t * the lockfile during install. If `false`, such flags or arguments should be omitted. Note that the command will\n\t * _not_ include the package manager name istself. For example, the `npm` package manager will return `[\"install\"]`,\n\t * not `[\"npm\", \"install\"]`.\n\t *\n\t * @example\n\t *\n\t * For the pnpm package manager, calling `getInstallCommandWithArgs(true)` would return\n\t * `[\"install\", \"--no-frozen-lockfile\"]`.\n\t */\n\tgetInstallCommandWithArgs(updateLockfile: boolean): string[];\n}\n\n/**\n * Information about a package dependency. That is, en extry in the \"dependencies\", \"devDependencies\", or\n * \"peerDependencies\" fields in package.json.\n */\nexport interface PackageDependency {\n\t/**\n\t * The name of the dependency.\n\t */\n\tname: PackageName;\n\n\t/**\n\t * The version or version range of the dependency.\n\t */\n\tversion: string;\n\n\t/**\n\t * The kind of dependency, based on the field that the dependency comes from.\n\t *\n\t * - prod corresponds to the dependencies field.\n\t * - dev corresponds to the devDependencies field.\n\t * - peer corresponds to the peerDependencies field.\n\t */\n\tdepKind: \"prod\" | \"dev\" | \"peer\";\n}\n\n/**\n * A tagged type representing package names.\n */\nexport type PackageName = Opaque<string, \"PackageName\">;\n\n/**\n * A common type representing an npm package. A custom type can be used for the package.json schema, which is useful\n * when the package.json has custom keys/values.\n *\n * @typeParam J - The package.json type to use. This type must extend the {@link PackageJson} type defined in this\n * package.\n */\nexport interface IPackage<J extends PackageJson = PackageJson>\n\textends Installable,\n\t\tReloadable {\n\t/**\n\t * The name of the package including the scope.\n\t */\n\treadonly name: PackageName;\n\n\t/**\n\t * The name of the package color-coded with ANSI color codes for terminal output. The package name will always have\n\t * the same color.\n\t */\n\treadonly nameColored: string;\n\n\t/**\n\t * The absolute path to the directory containing the package (that is, the directory that contains the package.json\n\t * for the package).\n\t */\n\treadonly directory: string;\n\n\t/**\n\t * The package.json contents of the package.\n\t */\n\tpackageJson: J;\n\n\t/**\n\t * The version of the package. This is the same as `packageJson.version`.\n\t */\n\treadonly version: string;\n\n\t/**\n\t * `true` if the package is private; `false` otherwise. This is similar to the field in package.json, but always\n\t * returns a boolean value. If the package.json is missing the `private` field, this will return false.\n\t */\n\treadonly private: boolean;\n\n\t/**\n\t * The workspace that this package belongs to.\n\t */\n\treadonly workspace: IWorkspace;\n\n\t/**\n\t * Whether the package is a workspace root package or not. A workspace will only have one root package.\n\t */\n\treadonly isWorkspaceRoot: boolean;\n\n\t/**\n\t * The name of the release group that this package belongs to.\n\t */\n\treleaseGroup: ReleaseGroupName;\n\n\t/**\n\t * Whether the package is a release group root package or not. A release group may not have a root package, but if it\n\t * does, it will only have one.\n\t */\n\tisReleaseGroupRoot: boolean;\n\n\t/**\n\t * The absolute path to the package.json file for this package.\n\t */\n\treadonly packageJsonFilePath: string;\n\n\t/**\n\t * Returns the value of a script in the package's package.json, or undefined if a script with the provided key is not\n\t * found.\n\t */\n\tgetScript(name: string): string | undefined;\n\n\t/**\n\t * Saves any changes to the packageJson property to the package.json file on disk.\n\t */\n\tsavePackageJson(): Promise<void>;\n\n\t/**\n\t * A generator that returns each dependency and the kind of dependency (dev, peer, etc.) for all of the package's\n\t * dependencies. This is useful to iterate overall all dependencies of the package.\n\t */\n\tcombinedDependencies: Generator<PackageDependency, void>;\n\ttoString(): string;\n}\n\n/**\n * A type guard that returns `true` if the item is an {@link IPackage}.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types -- this is a type guard\nexport function isIPackage(pkg: any): pkg is IPackage {\n\tif (typeof pkg === \"object\") {\n\t\treturn \"getScript\" in pkg;\n\t}\n\treturn false;\n}\n"]}