{"version":3,"file":"workspaceCompat.js","sourceRoot":"","sources":["../src/workspaceCompat.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation and contributors. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { existsSync } from \"node:fs\";\nimport * as path from \"node:path\";\n\nimport { globSync } from \"tinyglobby\";\n\nimport type {\n\t// eslint-disable-next-line import/no-deprecated -- back-compat code\n\tIFluidBuildDir,\n\t// eslint-disable-next-line import/no-deprecated -- back-compat code\n\tIFluidBuildDirs,\n\tReleaseGroupDefinition,\n\tWorkspaceDefinition,\n} from \"./config.js\";\nimport type { IBuildProject, IWorkspace, WorkspaceName } from \"./types.js\";\nimport { Workspace } from \"./workspace.js\";\nimport { WriteOnceMap } from \"./writeOnceMap.js\";\n\n/**\n * Loads workspaces based on the \"legacy\" config -- the former repoPackages section of the fluid-build config.\n *\n * **ONLY INTENDED FOR BACK-COMPAT.**\n *\n * @param entry - The config entry.\n * @param buildProject - The BuildProject the workspace belongs to.\n */\nexport function loadWorkspacesFromLegacyConfig(\n\t// eslint-disable-next-line import/no-deprecated -- back-compat code\n\tconfig: IFluidBuildDirs,\n\tbuildProject: IBuildProject,\n): Map<WorkspaceName, IWorkspace> {\n\tconst workspaces: Map<WorkspaceName, IWorkspace> = new WriteOnceMap();\n\n\t// Iterate over the entries and create synthetic workspace definitions for them, then load the workspaces.\n\tfor (const [name, entry] of Object.entries(config)) {\n\t\tconst loadedWorkspaces: IWorkspace[] = [];\n\t\tif (Array.isArray(entry)) {\n\t\t\tfor (const item of entry) {\n\t\t\t\tloadedWorkspaces.push(...loadWorkspacesFromLegacyConfigEntry(item, buildProject));\n\t\t\t}\n\t\t} else if (typeof entry === \"object\") {\n\t\t\tloadedWorkspaces.push(...loadWorkspacesFromLegacyConfigEntry(entry, buildProject, name));\n\t\t} else {\n\t\t\tloadedWorkspaces.push(...loadWorkspacesFromLegacyConfigEntry(entry, buildProject));\n\t\t}\n\t\tfor (const ws of loadedWorkspaces) {\n\t\t\tworkspaces.set(ws.name, ws);\n\t\t}\n\t}\n\n\treturn workspaces;\n}\n\n/**\n * Loads workspaces based on an individual entry in the the \"legacy\" config -- the former repoPackages section of the\n * fluid-build config. A single entry may represent multiple workspaces, so this function returns all of them. An\n * example of such a case is when a legacy config includes a folder that isn't itself a package (i.e. it has no\n * package.json). Such config entries are intended to include all packages found under the path, so they are each\n * treated as individual single-package workspaces and are loaded as such.\n *\n * **ONLY INTENDED FOR BACK-COMPAT.**\n *\n * @param entry - The config entry.\n * @param buildProject - The path to the root of the BuildProject.\n * @param name - If provided, this name will be used for the workspace. If it is not provided, the name will be derived\n * from the directory name.\n */\nfunction loadWorkspacesFromLegacyConfigEntry(\n\t// eslint-disable-next-line import/no-deprecated -- back-compat code\n\tentry: string | IFluidBuildDir,\n\tbuildProject: IBuildProject,\n\tname?: string,\n): IWorkspace[] {\n\tconst directory = typeof entry === \"string\" ? entry : entry.directory;\n\tconst rgName = name ?? path.basename(directory);\n\tconst workspaceName = rgName;\n\tconst releaseGroupDefinitions: {\n\t\t[name: string]: ReleaseGroupDefinition;\n\t} = {};\n\treleaseGroupDefinitions[rgName] = {\n\t\tinclude: [\"*\"],\n\t};\n\n\t// BACK-COMPAT HACK - assume that a directory in the legacy config either has a package.json -- in which case the\n\t// directory will be treated as a workspace root -- or it does not, in which case all package.json files under the\n\t// path will be treated as workspace roots.\n\tconst packagePath = path.join(buildProject.root, directory, \"package.json\");\n\tif (existsSync(packagePath)) {\n\t\tconst workspaceDefinition: WorkspaceDefinition = {\n\t\t\tdirectory,\n\t\t\treleaseGroups: releaseGroupDefinitions,\n\t\t};\n\n\t\treturn [\n\t\t\tWorkspace.load(workspaceName, workspaceDefinition, buildProject.root, buildProject),\n\t\t];\n\t}\n\n\tconst packageJsonPaths = globSync([\"**/package.json\"], {\n\t\tcwd: path.dirname(packagePath),\n\t\tignore: [\"**/node_modules/**\"],\n\t\tonlyFiles: true,\n\t\tabsolute: true,\n\t\t// BACK-COMPAT HACK - only search two levels below entries for package.jsons. This avoids finding some test\n\t\t// files and treating them as packages. This is only needed when loading old configs.\n\t\tdeep: 2,\n\t}).map(\n\t\t// Make the paths relative to the repo root\n\t\t(filePath) => path.relative(buildProject.root, filePath),\n\t);\n\tconst workspaces = packageJsonPaths.flatMap((pkgPath) => {\n\t\tconst dir = path.dirname(pkgPath);\n\t\treturn loadWorkspacesFromLegacyConfigEntry(dir, buildProject);\n\t});\n\treturn workspaces;\n}\n"]}