import { readFile, writeFile } from "node:fs/promises";
import path from "pathe";
import { makePolicyDefinition } from "../makePolicy.js";
import type {
	PolicyDefinition,
	PolicyFailure,
	PolicyFixResult,
} from "../policy.js";

/**
 * Policy settings for the RequiredGitignorePatterns repo policy.
 *
 * @alpha
 */
export interface RequiredGitignorePatternsSettings {
	/**
	 * Array of patterns that must be present in .gitignore.
	 * Each pattern can be a string or an object with pattern and comment.
	 */
	patterns: Array<string | { pattern: string; comment?: string }>;
}

/**
 * Default patterns that should typically be in .gitignore files.
 */
const DEFAULT_PATTERNS = [
	{ pattern: "node_modules/", comment: "Dependencies" },
	{ pattern: ".env", comment: "Environment files" },
	{ pattern: ".env.*", comment: "Environment files" },
	{ pattern: "!.env.example", comment: "Allow example env file" },
	{ pattern: "dist/", comment: "Build output" },
	{ pattern: "build/", comment: "Build output" },
	{ pattern: ".DS_Store", comment: "macOS system files" },
	{ pattern: "Thumbs.db", comment: "Windows system files" },
];

/**
 * Check if a pattern exists in gitignore content.
 * Handles patterns with inline comments (e.g., "node_modules/ # comment").
 */
function patternExists(lines: string[], pattern: string): boolean {
	return lines.some((line) => {
		const trimmed = line.trim();
		// Remove inline comments (everything after # that's not escaped)
		const withoutComment = trimmed.split("#")[0]?.trim() ?? "";
		return (
			withoutComment === pattern ||
			trimmed === pattern ||
			trimmed.startsWith(`${pattern} `) ||
			trimmed.startsWith(`${pattern}\t`)
		);
	});
}

/**
 * Find missing patterns in gitignore content.
 */
function findMissingPatterns(
	patterns: Array<string | { pattern: string; comment?: string }>,
	lines: string[],
): Array<string | { pattern: string; comment?: string }> {
	const missingPatterns: Array<string | { pattern: string; comment?: string }> =
		[];

	for (const patternConfig of patterns) {
		const pattern =
			typeof patternConfig === "string" ? patternConfig : patternConfig.pattern;

		if (!patternExists(lines, pattern)) {
			missingPatterns.push(patternConfig);
		}
	}

	return missingPatterns;
}

/**
 * Add patterns to gitignore content.
 */
function addPatternsToContent(
	content: string,
	missingPatterns: Array<string | { pattern: string; comment?: string }>,
): string {
	let newContent = content;

	// Ensure file ends with newline
	if (!newContent.endsWith("\n")) {
		newContent += "\n";
	}

	// Add a section header if we're adding patterns
	if (missingPatterns.length > 0) {
		newContent += "\n# Added by repopo RequiredGitignorePatterns policy\n";
	}

	// Add each missing pattern
	for (const patternConfig of missingPatterns) {
		if (typeof patternConfig === "string") {
			newContent += `${patternConfig}\n`;
		} else {
			if (patternConfig.comment) {
				newContent += `# ${patternConfig.comment}\n`;
			}
			newContent += `${patternConfig.pattern}\n`;
		}
	}

	return newContent;
}

/**
 * Create gitignore content from scratch.
 */
function createGitignoreContent(
	patterns: Array<string | { pattern: string; comment?: string }>,
): string {
	let content = "# Generated by repopo RequiredGitignorePatterns policy\n\n";

	for (const patternConfig of patterns) {
		if (typeof patternConfig === "string") {
			content += `${patternConfig}\n`;
		} else {
			if (patternConfig.comment) {
				content += `# ${patternConfig.comment}\n`;
			}
			content += `${patternConfig.pattern}\n`;
		}
	}

	return content;
}

/**
 * Handle the case when .gitignore exists.
 */
async function handleExistingGitignore(
	filePath: string,
	patterns: Array<string | { pattern: string; comment?: string }>,
	file: string,
	resolve: boolean,
): Promise<true | PolicyFailure | PolicyFixResult> {
	const gitignoreContent = await readFile(filePath, "utf-8");
	const lines = gitignoreContent.split("\n");
	const missingPatterns = findMissingPatterns(patterns, lines);

	if (missingPatterns.length === 0) {
		return true;
	}

	const result: PolicyFailure = {
		name: RequiredGitignorePatterns.name,
		file,
		autoFixable: true,
		errorMessages: [
			`Missing required .gitignore patterns: ${missingPatterns.map((p) => (typeof p === "string" ? p : p.pattern)).join(", ")}`,
		],
	};

	if (resolve) {
		const fixResult: PolicyFixResult = {
			...result,
			resolved: false,
		};

		try {
			const newContent = addPatternsToContent(
				gitignoreContent,
				missingPatterns,
			);
			await writeFile(filePath, newContent);
			fixResult.resolved = true;
		} catch (error: unknown) {
			fixResult.errorMessages = [
				`Failed to update .gitignore: ${(error as Error).message}`,
			];
		}

		return fixResult;
	}

	return result;
}

/**
 * Handle the case when .gitignore doesn't exist.
 */
async function handleMissingGitignore(
	filePath: string,
	patterns: Array<string | { pattern: string; comment?: string }>,
	file: string,
	resolve: boolean,
): Promise<PolicyFailure | PolicyFixResult> {
	const result: PolicyFailure = {
		name: RequiredGitignorePatterns.name,
		file,
		autoFixable: true,
		errorMessages: ["No .gitignore file found in repository root"],
	};

	if (resolve) {
		const fixResult: PolicyFixResult = {
			...result,
			resolved: false,
		};

		try {
			const content = createGitignoreContent(patterns);
			await writeFile(filePath, content);
			fixResult.resolved = true;
		} catch (writeError: unknown) {
			fixResult.errorMessages = [
				`Failed to create .gitignore: ${(writeError as Error).message}`,
			];
		}

		return fixResult;
	}

	return result;
}

/**
 * A repo policy that ensures .gitignore contains required patterns to prevent
 * committing sensitive files, dependencies, and build artifacts.
 *
 * @alpha
 */
export const RequiredGitignorePatterns: PolicyDefinition<RequiredGitignorePatternsSettings> =
	makePolicyDefinition({
		name: "RequiredGitignorePatterns",
		description:
			"Ensures .gitignore contains required patterns to prevent committing sensitive files, dependencies, and build artifacts.",
		match: /^\.gitignore$/,
		handler: async ({ file, root, resolve, config }) => {
			const patterns = config?.patterns ?? DEFAULT_PATTERNS;
			const filePath = path.join(root, file);

			try {
				return await handleExistingGitignore(filePath, patterns, file, resolve);
			} catch (_error: unknown) {
				return await handleMissingGitignore(filePath, patterns, file, resolve);
			}
		},
	});
