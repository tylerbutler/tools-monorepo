import { readFile, writeFile } from "node:fs/promises";
import { EOL as newline } from "node:os";
import type { PolicyFailure, PolicyFixResult, RepoPolicy } from "../policy.js";

const headerText = "HEADER";
const autoGenText = `${newline}THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY`;

const trailingSpaces = /\s*\\r\?\\n/;

interface IFileConfig {
	match: RegExp;

	/**
	 * File type reported in error message (e.g., 'Html')
	 */
	type: string;

	/**
	 * Regex matching header prefix (e.g. '/*!\r?\n')
	 */
	headerStart?: RegExp;

	/**
	 * Regex matching beginning of each line (e.g. ' * ')
	 */
	lineStart: RegExp;

	/**
	 * Regex matching the end of each line (e.g., '\r?\n')
	 */
	lineEnd: RegExp;

	/**
	 * Regex matching the header postfix.
	 */
	headerEnd?: RegExp;
}

/**
 * Given an 'IFileConfig' produces a function that detects correct copyright headers
 * and returns an error string if the header is missing or incorrect.
 */
export function generateFileHeaderPolicy(
	name: string,
	config: IFileConfig,
): RepoPolicy {
	const pre = config.headerStart?.source ?? "";
	const start = config.lineStart.source;
	const end = config.lineEnd.source;
	const post = config.headerEnd?.source ?? "";

	// Helper which constructs a matching RegExp from a given multiline strings.
	// (See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping)
	const toRegex = (text: string): string =>
		text
			.split(newline)
			.map(
				(line) =>
					`${start}${line.replace(/[$()*+.?[\\\]^{|}]/g, "\\$&")}${end}`,
			)
			.join("")
			.replace(trailingSpaces, "\\r?\\n"); // Trim trailing spaces at end-of-line.

	// Detection regex matches the header start (if any), followed by lines in 'copyrightText',
	// optionally followed by lines in the 'autoGenText', and finally the header end (if any).
	const regex = new RegExp(
		`^${pre}${toRegex(headerText)}(${toRegex(autoGenText)})?${post}`,
	);

	return {
		name,
		match: config.match,
		handler: async ({ file, resolve }) => {
			const failResult: PolicyFailure = {
				name,
				file,
				autoFixable: true,
			};

			// TODO: Consider reading only the first 512B or so since headers are typically
			// at the beginning of the file.
			const content = await readFile(file, { encoding: "utf8" });
			const failed = !regex.test(content);

			if (failed) {
				failResult.errorMessage = `${config.type} file missing header`;
			}

			if (failed) {
				if (resolve) {
					const newContent = `<!-- ${headerText.replace(
						newline,
						` -->${newline}<!-- `,
					)} -->${newline}${newline}${content}`;

					await writeFile(file, newContent);

					const fixResult: PolicyFixResult = {
						...failResult,
						resolved: true,
					};

					return fixResult;
				}
				return failResult;
			}

			return true;
		},
	};
}
