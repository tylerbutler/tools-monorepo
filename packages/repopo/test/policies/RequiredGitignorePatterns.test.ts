import { afterEach, beforeEach, describe, expect, it } from "vitest";
import { mkdirSync, rmSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { tmpdir } from "node:os";
import { RequiredGitignorePatterns } from "../../src/policies/RequiredGitignorePatterns.js";

describe("RequiredGitignorePatterns", () => {
	let testDir: string;
	let gitignoreFile: string;

	beforeEach(() => {
		// Create a unique test directory
		testDir = join(tmpdir(), `repopo-test-${Date.now()}-${Math.random().toString(36).slice(2)}`);
		mkdirSync(testDir, { recursive: true });
		gitignoreFile = join(testDir, ".gitignore");
	});

	afterEach(() => {
		// Clean up test directory
		rmSync(testDir, { recursive: true, force: true });
	});

	describe("policy matching", () => {
		it("should match .gitignore files", () => {
			expect(RequiredGitignorePatterns.match.test(".gitignore")).toBe(true);
		});

		it("should not match other files", () => {
			expect(RequiredGitignorePatterns.match.test("package.json")).toBe(false);
			expect(RequiredGitignorePatterns.match.test("src/.gitignore")).toBe(false);
			expect(RequiredGitignorePatterns.match.test("gitignore")).toBe(false);
		});
	});

	describe("existing .gitignore with all required patterns", () => {
		beforeEach(() => {
			writeFileSync(gitignoreFile, `# Dependencies
node_modules/

# Environment files
.env
.env.*
!.env.example

# Build output
dist/
build/

# System files
.DS_Store
Thumbs.db
`);
		});

		it("should pass when all default patterns are present", async () => {
			const result = await RequiredGitignorePatterns.handler({
				file: ".gitignore",
				root: testDir,
				resolve: false,
			});

			expect(result).toBe(true);
		});
	});

	describe("existing .gitignore with missing patterns", () => {
		beforeEach(() => {
			writeFileSync(gitignoreFile, `# Just a basic gitignore
node_modules/
.env
`);
		});

		it("should fail when patterns are missing", async () => {
			const result = await RequiredGitignorePatterns.handler({
				file: ".gitignore",
				root: testDir,
				resolve: false,
			});

			expect(result).not.toBe(true);
			if (typeof result === "object") {
				expect(result.name).toBe("RequiredGitignorePatterns");
				expect(result.autoFixable).toBe(true);
				expect(result.errorMessage).toContain("Missing required .gitignore patterns");
			}
		});

		it("should auto-fix by adding missing patterns", async () => {
			const result = await RequiredGitignorePatterns.handler({
				file: ".gitignore",
				root: testDir,
				resolve: true,
			});

			expect(result).not.toBe(true);
			if (typeof result === "object" && "resolved" in result) {
				expect(result.resolved).toBe(true);
			}

			// Check that patterns were added
			const fs = await import("node:fs");
			const updatedContent = fs.readFileSync(gitignoreFile, "utf-8");
			expect(updatedContent).toContain(".env.*");
			expect(updatedContent).toContain("dist/");
			expect(updatedContent).toContain(".DS_Store");
			expect(updatedContent).toContain("repopo RequiredGitignorePatterns policy");
		});
	});

	describe("missing .gitignore file", () => {
		it("should fail when .gitignore doesn't exist", async () => {
			const result = await RequiredGitignorePatterns.handler({
				file: ".gitignore",
				root: testDir,
				resolve: false,
			});

			expect(result).not.toBe(true);
			if (typeof result === "object") {
				expect(result.name).toBe("RequiredGitignorePatterns");
				expect(result.autoFixable).toBe(true);
				expect(result.errorMessage).toContain("No .gitignore file found");
			}
		});

		it("should auto-fix by creating .gitignore with all patterns", async () => {
			const result = await RequiredGitignorePatterns.handler({
				file: ".gitignore",
				root: testDir,
				resolve: true,
			});

			expect(result).not.toBe(true);
			if (typeof result === "object" && "resolved" in result) {
				expect(result.resolved).toBe(true);
			}

			// Check that file was created with all patterns
			const fs = await import("node:fs");
			const content = fs.readFileSync(gitignoreFile, "utf-8");
			expect(content).toContain("node_modules/");
			expect(content).toContain(".env");
			expect(content).toContain("dist/");
			expect(content).toContain("Generated by repopo");
		});
	});

	describe("custom configuration", () => {
		it("should use custom patterns when provided", async () => {
			writeFileSync(gitignoreFile, "node_modules/\n");

			const customConfig = {
				patterns: ["custom-pattern/", { pattern: "*.log", comment: "Log files" }],
			};

			const result = await RequiredGitignorePatterns.handler({
				file: ".gitignore",
				root: testDir,
				resolve: false,
				config: customConfig,
			});

			expect(result).not.toBe(true);
			if (typeof result === "object") {
				expect(result.errorMessage).toContain("custom-pattern/");
				expect(result.errorMessage).toContain("*.log");
			}
		});

		it("should auto-fix with custom patterns", async () => {
			writeFileSync(gitignoreFile, "# Basic file\nnode_modules/\n");

			const customConfig = {
				patterns: [
					"custom-dir/",
					{ pattern: "*.secret", comment: "Secret files" },
				],
			};

			const result = await RequiredGitignorePatterns.handler({
				file: ".gitignore",
				root: testDir,
				resolve: true,
				config: customConfig,
			});

			if (typeof result === "object" && "resolved" in result) {
				expect(result.resolved).toBe(true);
			}

			const fs = await import("node:fs");
			const content = fs.readFileSync(gitignoreFile, "utf-8");
			expect(content).toContain("custom-dir/");
			expect(content).toContain("*.secret");
			expect(content).toContain("# Secret files");
		});
	});

	describe("edge cases", () => {
		it("should handle .gitignore with existing patterns that have comments", async () => {
			writeFileSync(gitignoreFile, `node_modules/ # npm dependencies
.env # environment variables
dist/ # build output
.DS_Store
Thumbs.db
.env.*
!.env.example
build/
`);

			const result = await RequiredGitignorePatterns.handler({
				file: ".gitignore",
				root: testDir,
				resolve: false,
			});

			expect(result).toBe(true);
		});

		it("should handle .gitignore without final newline", async () => {
			writeFileSync(gitignoreFile, "node_modules/");

			const result = await RequiredGitignorePatterns.handler({
				file: ".gitignore",
				root: testDir,
				resolve: true,
			});

			if (typeof result === "object" && "resolved" in result) {
				expect(result.resolved).toBe(true);
			}

			const fs = await import("node:fs");
			const content = fs.readFileSync(gitignoreFile, "utf-8");
			expect(content).toMatch(/node_modules\/\n/);
			expect(content.endsWith("\n")).toBe(true);
		});
	});
});